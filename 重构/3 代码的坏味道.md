# 3 代码的坏味道

## 3.1 Duplicated Code 重复代码

+ 同一个类的两个方法出现重复代码块，应该使用**提炼方法**（6.1）提炼出重复代码。

+ 两个互为兄弟的子类含有重复代码块，对两个类使用提炼方法（6.1），然后在使用**方法上移**（11.2），将其推入超类。
+ 如果两个方法中的代码只是类似，那么就使用提炼方法（6.1），将代码中相似部分和差异进行切割，构成单独函数，然后使用**模板方法**（11.10）

+ 如果两个毫不相关的类中出现重复代码块， 应该考虑对其中一个使用**提炼类**（7.3），将重复的代码提炼到一个独立的类中。

## 3.2 Long Method 过长函数

有效切分过长的方法，可以帮助我们在“做什么”和“怎么做”之间进行切分。我们可以按照以下原则进行：每当感觉需要注释来说明的时候，我们就把需要说明的东西写入独立的方法中，并以用途（而非实现手法）命名。

+ 大多数情况下，要把函数变小，只需要提炼方法（6.1）即可。
+ 如果方法中有大量的参数和临时变量，就会对提炼方法形成阻碍。如果尝试使用提炼方法，就会把许多参数和临时变量作为参数，传递给被提炼的方法，导致可读性几乎没有变化。这个时候我们可以使用**以查询来取代临时变量**（6.4）消除这些临时变量，使用**引入参数对象**（10.9）和**保持对象完整**（10.7）可以将过长的参数列变得更简洁。如果这样做后，依然有太多临时变量和参数，那就使用我们的杀手锏**以函数对象取代函数**（6.8）。

## 3.3 Large Class 过大的类

如果一个类的功能太多，其内往往就会出现太多实例变量。一旦如此，重复代码也接踵而至。

+ 运用**提炼类**（7.3）将彼此相关联的变量提炼到新类中，如果这个新类适合作为一个子类，可以使用**提炼子类**（11.6）。

## 3.4 Long Parameter List 过长参数列 

过长的参数存在难以理解、不易使用、不易修改的问题。

## 3.5 Divergent Change 发散式变化

如果某个类因为不同的原因在不同的方向上发生变化就是发散式变化。

## 3.6 Shotgun Surgery 散弹式修改

与发散式变化类似，但恰恰想法。如果每遇到某种变化，都需要在许多不同的类中做出修改，这种就是散弹式修改。

## 3.7 Feature Envy 依恋情结

一个类中的函数对某个类的数据依赖高于对自己的所在类的依赖，这种就是依恋情结。

## 3.8 Data Clumps 数据泥团

两个类中相同的字段，许多函数签名中相同的参数，这些没有自己所属对象的数据，就是数据泥团。

## 3.9 Primitive Obsession 基本类型偏执

3.10 Switch Statements switch惊悚现身

3.11 Parallel Inheritance Hierarchies 平行继承体系

3.12 Lazy Class 冗赘类

3.13 Speculative Generality 夸夸其谈未来性

3.14 Temporary Field 令人迷惑的暂时字段

3.15 Message Chains 过度耦合的消息链

3.16 Middle Man 中间人

3.17 Inappropriate Intimacy 不适当的亲昵关系

3.18 Altemative Classse With Different Interface 异曲同工的类

3.19 Incomplete Library Class 不完美的类库

3.20Data Class 纯粹的数据类型

3.21 Refused Bequest 被拒绝的遗赠

3.22 Comments 过多的注释