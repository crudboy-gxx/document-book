# 2 重构原则

## 2.1 何为重构

> 重构，就是在**不改变软件可观察行为**的前提下，对软件内部结构的一种调整，以**提高软件的可理解新和降低软件的修改成本**。

在使用重构技术开发软件时，我们可以把时间分配给两种行为，一个是添加新功能，第二个是重构。添加新功能的时候，不应该修改既有代码，而只管添加新功能。重构时不应该在添加新功能，而只管改进程序结构。

我们在开发过程中，这两个过程往往是交替进行。首先添加了新功能，然后意识到如果把程序结构改下，功能添加会更容易，然后开始重构，重构好了在继续进行新功能添加。在这个过程中，我们要保持同一时间要么在添加新功能，要么在重构，不要让这两个过程混乱交织起来。

## 2.2 为何重构

我们不能把重构当做软件开发中的“银弹”，但是，重构可以帮助我们良好的控制代码。重构是一个工具，他可以用于以下几个目的。

+ 改进软件设计

  如果没有重构，程序的设计就会逐渐腐败。在完全理解整体的业务和设计之前，我们通常会不断进行需求变更，我们就会变动我们代码。这种变动，往往会引入腐败的元素，导致代码结构的流失，例如重复的代码、多余的代码等。因此，我们需要通过重构来整理代码，以保证代码的结构。

+ 使得软件更容易理解

  代码的可阅读性是一个不可忽略的要求。重构赋予了代码更好的结构，更好的代码结构将带来更好的阅读性；更好的阅读性会使得代码更容易理解。另外，重构可以将你带到更高的理解层次上，因为重构过程中，通常可以使你发现更多的设计层面的东西。

+ 帮助找到BUG

+ 提高编码速度

  有人可能会提出疑问，重构需要时间吗？重构不会降低开发速度吗？

  我们要绝对的相信：良好的设计是快速开发的根本。事实上，拥有良好的设计才可以做到快速开发，才能快速的相应需求的变化。如果没有良好设计，或许在某一段时间内你的进展迅速，但是恶劣的设计很快就会让你的速度慢下来。时间越长，这种恶劣的设计带来的影响就越大，使我们修改和添加功能变得非常耗费时间。

## 2.3 何时重构

> 事不过三，三责重构

不要专门拨出时间来进行重构，重构应该随时随地的进行，不应该为了重构而重构。之所以重构，是以你为你想做别的事，而重构可以帮助你把这些事做好。

+ 添加功能时

  代码的设计无法帮助我们轻松添加所需的特性，通过重构来理解需要修改的代码，来让新特性添加时更轻松。

+ 修补错误时

  调试修补过程中重构，多数是为了让代码更具可读性。

+ 复审代码时

  代码复审可以有效的改善代码质量，可以让知识在团队中传播。重构可以帮助我们复审别人的代码。

## 2.4 怎么对经理说

淦！

## 2.5 重构的难题

+ 数据库

  重构的难点之一是对数据库结构的变更。程序与数据库是紧密耦合的，我们的重构过程很可能会使得数据库的结构发生变化。在非对象数据库中，解决这个问题的办法之一就是，**在对象模型和数据库模型之间插入一个分割层**，这样就可以隔离两个模型的各自变化。？什么样的分割层？

+ 修改接口

  如果接口的调用者都在你的掌握之下，那么修改接口不会问题。但是，接口发布后就不能轻易修改接口。如果重构改变了可行的发布接口，你必须维护新旧两个接口，并且最好使用旧接口调用新的接口。另一种方法就是不要过早的发布接口。

+ 难以通过重构完成的设计改动

  有些设计层面的错误，重构时无法有效的解决。这种情况下，我们首先先考虑将设计重构的难度有多大，如果很简单就不用太担心，选择直接重构就可以。如果重构难度比较大，那就优先进行重新设计。

+ 何时不该重构

  有时候代码太过混乱，重构还不如重写来的简单。项目接近尾声，应该尽量避免重构。

## 2.6 重构与设计

重构可以和设计进行互补。很多人都把设计看做软件开发的关键环节，而把编程看做是机械式的劳动，其实并非如此。有了设计可以让我们思考的更快，但是设计无法细到每个点，只有真正编码的时候才能发现非常细小的问题。因此，我们可以使用重构来对设计进行补充。

重构可以带来更简单的设计。在没有应用重构之前，我们总是力求得到完美的或者灵活的解决方案，这样使得设计的压力非常大。当我们选择加入重构之后，我们可以选择一个足够合理但简单的解决方案。然后，随着对问题理解的加身，我们不断的修正之前的解决方案，只要有重构，就不会让日后的修改变得举步维艰。

## 2.7 重构与性能

我们在关注软件的易读性的时候，会不会做出是程序变慢的修改呢？我并不赞成为了提高设计的纯洁性而忽视性能的做法。但是编写快速的软件的方法就是：编写可阅读易调试的软件，然后调整它以求获得做够的速度。

我们对软件进行性能分析，大部分时间都消耗在一小段代码上。良好的代码在手，能够快速的添加功能，可以让我们拥有很多时间进行性能调整。其次，良好的代码，有助于寻找性能瓶颈的代码。因此，重构可以帮助我们写出更快的软件。

## 2.8 重构起源何处

管他起源何处，学会使用，淦就完事了！

