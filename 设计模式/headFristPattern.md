# headFristPattern

> 创建型（工厂方法 抽象工厂 单例 创建者/生成器 原型 ）
>
> 结构型（装饰器 适配器 外观 组合 代理 桥接 ）
>
> 行为型（策略 模版方法 观察者 迭代器 命令 状态 责任链 访问者 中介者 解释器 备忘录）
>
>  
>
> 接口型（适配器 外观 合成/组合 桥接 ）
>
> 构造性（创建者/生成器 工厂方法 抽象工厂 原型 备忘录）
>
> 职责型（单例 观察者 调停者/中介者 代理 职责链）
>
> 操作型（模版方法 状态 策略 命令 解释器）
>
> 扩展型（装饰器 迭代器 访问者）



1.以升级鸭子模具引出 策略模式（定义算法组，分别将算法组进行封装，让他们之间可以互相替代，此模式将变化的算法独立于算法的使用者）

2.以气象站建立引出 观察者模式（在对象之间定义一对多的依赖，这样一来一个对象改变状态，依赖的对象都能获得通知，并更新自己）

3.以星巴克咖啡订单引出 装饰者模式（动态的将责任附加在对象上，想要扩展功能，装饰者提供了有别与集成的另一种选择）

4.以生产披萨引出 工厂方法模式（定义一个创建对象的接口。但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类中）

  抽象工厂模式（提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类）

5.以巧克力锅炉引出 单例模式（确保一个类只有一个实例，并提供一个全局访问点）

6.以遥控器引出 命令模式（将请求封装成对象，以便使用不同的请求或者队列来参数化其他命令）

7.以火鸡模具当作鸭子模具来使用引出 适配器模式（将一个类的接口，转换成客户所期望的另一个接口。适配器可以让原本接口不兼容的类可以合作）

  以修建家庭影院引出 外观模式（提供一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易访问）

8.以冲泡咖啡和茶引出 模版方法模式（在用个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤）

9.以早餐屋和午餐屋的菜单差异引出（array和list） 迭代模式（提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的结构）

  以午饭菜单中加入甜点菜单引出 组合模式（允许你将对象组合成树的结构来表现‘整体/部分’层次结构，组合能让客户以一致的方式处理个别对象以及对象组合）

10.以创建糖果机引出 状态模式（允许对象在内部状态改变时改变他的行为，对象看起来好像修改了他的类）

11.以远程监控糖果机引出 代理模式（为另一个对象提供一个替身或者占位符以控制对这个对象的访问）

 

**设计原则：**

1.封装变化，将应用中的变化和不变化进行分离。

2.针对接口编程，不针对实现编程（接口隔离）。

3.多用组合，少用继承。

4.为交互对象之间的松耦合设计而努力。

5.对扩展开放，对修改关闭（开闭）。

6.要依赖抽象，而不是依赖具体的类（依赖倒置）。

7.最少知识原则，和最少的对象耦合。

8.由超类主控一切，当他们需要的时候自然就会去调用子类。

9.单一职责，一个类应该只有一个引起变化的原因（单一职责）。

 

**其他****oop****思想：**

策略模式：

1.oop简单原则：高聚合、低耦合、可复用、易扩展、可维护

 

装饰者模式：

1.继承不仅能够复用代码，还有保证类型一致的作用。

2.依赖继承的话，类的行为在编译时期就确定下来了。

 

工厂方法模式

1.静态的方法不能通过集成来改变方法的行为。

2.简单工厂和工厂方法类似，简单工厂由本工厂产生对象，而工厂方法由子类的工厂方法产生对象。

3.当实例化一个对象的时候，就是在依赖具体的类。

4.工厂方法遵循的原则：变量不可持有具体类的引用，如果new就会持有，应该改为工厂方法来避免；不要让类派生自具体类，如果派生自具体类就会依赖具体类，应该派生自一个抽象类；不要覆盖基类中已实现的方法，如果覆盖了基类中已实现的方法，那么这个基类就不是一个适合被继承的抽象。

5.抽象工厂实质上是利用工厂方法来实现的，抽象工厂的作用是定义一个负责创建一组产品的接口，而具体的实现则是抽象工厂的子类来实现，这正式工厂方法的模式。

6.抽象工厂和工厂比较：工厂方法使用继承，将创建对象委托给子类，子类实现工厂方法来创建子类；抽象工厂使用对象组合，对象的创建被实现在工厂方法所暴露出来的方法中。

 

单例模式

1.在需要的时候在创建对象。

2.经典单例模式和经典线程同步单例模式，经典线程同步的问题是在每次调用静态方法都要检查。解决线程降低性能的一些方式：1）在加载类的时候直接创建静态对象，然后用静态方法返回，但是这样就不能懒惰加载了。2）另一种方法用双重检查，先检查是否已经创建对象，没创建然后在加锁创建。3）**使用静态内部类或者枚举是最好的方式**。

3.注意：多个加载器会导致单例失效而产生多个实例。

 

命令模式

1.空对象的妙用，在命令中有一个空对象，在没有初始化其他命令的时候就执行这个空的对象不发生任何行为，否则就会出现错误（空指针）

2.命令模式的使用，队列请求（一个接收者，一组动作）和日志请求

3.聪明命令对象，是直接实现请求，而不是将工作委托给接收者。

 

适配器模式

1.双向适配器？

2.对象适配器使用组合持有被适配者（实现目标接口），类适配器使用多重继承（实现目标接口并继承被适配者）。对象适配能适配被适配者的子类，但是要实现代码去对应被适配者的方法，而类适配器虽然只能适配一个类但是却不用写那么多代码去实现被适配者。

3.适配器现实中的经典例子：迭代器Iterator和枚举器Enumeration之间适配

 

外观模式

1.外观模式将问题简化，提供一个简单的方法来实现子系统功能，但是如果外观接口不符合要求，也可以直接改变子系统。

2.外观模式虽然和适配器模式一样对类进行了包装，但是两者存在根本的差异，适配器是为了转换不同的接口，而外观模式是为了简化接口。外观模式不只是简化了接口，同时也客户从子系统中解耦出来。

3.最少知识原则解析：就任何对象而言，在该对象的方法内我们原则上只调用属于一下范围的方法

1）该对象本身的方法 

2）被当作参数传进来的对象方法 

3）此方法创建或者实例化的对象 

如果某对象是调用其他对象方法的返回结果不要调用该对象。

 

模版方法模式

1.钩子，钩子是一个被声明在抽象类中的方法，但只有一个空的或者默认实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。要不要挂钩由子类自己决定。

钩子的作用：

1）钩子可以影响模版方法（算法）的执行流程（选择执行或者不执行某一个步骤）。

2）可以让子类对模版方法中某些方法的执行前后做出反映。

在冲咖啡和泡茶的实例中，模版方法可以进行判断，如果钩子方法返回true可以执行加入其他调料，在子类中，重写钩子方法，让子类自己决定要不要加入调料。

钩子方法和回调方法？

2.模版方法模式在设计框架的时候是个很好的选择，让框架决定控制如何做事情，而由你指定算法的具体细节。

3.现实中的模版方法变形：数组的排序，被排序者要实现comparable接口

 

迭代器模式

1.集合，指的是一群对象，其存储方式可以是各种各样的数据结构，例如数组、列表、散列表。

2.内部迭代器？

 

组合模式

1.组合迭代器？普通的树形迭代器是内部迭代器，有内部自行递归。组合迭代器是在外部控制迭代。组合迭代器的重点是要保存当前所在位置

 

状态模式

1.状态模式是将状态和状态的行为封装，而调用者的行为是通过委托给当前状态的行为实现的，当在不同状态的时候行为自然不同。

2.状态模式和策略模式，两者的类图是一样的；状态模式是将行为封装在状态中，调用者将行为委托给状态中的行为，随着程序运行调用者在不同状态之间游走的，以反映出调用者内部的状态改变，因此行为也在发生改变，但是客户对调用者的改变并不知晓；而策略模式，客户通常指定调用这使用哪一种策略对象，虽然策略模式更有弹性，但对于某一个调用者来说只有一个最适应的策略对象。

 

代理模式

1.远程代理，使用RMI技术；虚拟代理，用来代理开销大的对象；java的动态代理；防火墙代理；只能引用代理；缓存代理；同步代理；外观代理；

 

结构型模式用来描述类和对象如何被组合以建立新的结构或功能；行为型模式用来描述对象之间的沟通和互联。