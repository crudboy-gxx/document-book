# 04 深入浅出索引（上）
## 本期问题
+ 重建主键索引不推荐使用删除在新增的方式，要使用`alter table T engine=InnoDB`，这样子就会原地重建表结构。
## 同学讨论


# 05 深入浅出所以索引（下）
+ 回表：回到主键索引树搜索的过程。
+ 覆盖索引：SQL语句只通过索引，就取到了所需要的数据，这个过程就叫做索引覆盖。
  + 覆盖索引直接从索引中获取数据，避免回表二次查询，提升性能。
+ 最左前缀原则：索引从左到右进行匹配。
  + B+树这种索引结构，是按照从做到右的顺序来创建索引树的。
  + 为了使用最左前缀原则，在创建联合索引的时候，就需要根据应用场景来安排索引顺序。
    + 评估的原则就是索引的复用能力，如果通过调整顺序可以少维护一个索引，那么这个顺序就是优先考虑采用的。
    + 如果在有联合索引的情况下，必须单独维护另一个索引，考虑的原则就是空间，单独的建议是占用空间小的。
+ 索引下推：在索引遍历中，对索引包含的字段优先判断，直接过滤到不满足条件的记录，减少回表次数。
## 本期问题
+ 对联合主键索引和InnoDB索引组织表的理解。
## 同学讨论


# 06 全局锁和表锁-给表价格字段怎么有这么多阻碍
+ 全局锁：对数据库实例加锁，使全库进入只读状态，应用场景就是全库逻辑备份。`Flush tables with read lock (FTWRL)`
  + 如果全库支持事务，备份的时候有推荐使用mysqlsump的`-single-transaction`参数，导出前会启动一个事务，来保证拿到一致性视图。如果不是全库支持事务，要使用FTWRL命令。
  + 设置全局只读变量`readonly = true`会导致的问题。1）readonly的值会被用来做其他逻辑，例如一个库是主库还是从库。2）readonly如果客户端发生异常，数据库会一直保持这个状态，导致库不可用。3）readonly对超级管理员是无效。不推荐使用。
+ 表级锁：表级锁有两种方式，一种是表锁，一种元数据锁（MDL）。
  + 表锁语法`lock tables … read/write`，
  + MDL锁在访问表时会自动加上，不需要显示使用。对表增删改查操作加读锁，对表做结构变更操作加写锁。
    + MDL机制造成的问题：当变更表的结构时，会加上写锁，其他客户端无论是读锁还是写锁都会被阻塞，这个表的表现就是无法读写。如果客户端有重试机制，超时后会在起一个新的session，那么个库的线程很快就会爆满。
    + 如何给一个小表加字段：首先，如果要变更的表有长事务，无法获取MDL锁，可以将长事务kill掉。如果是热度表会被频繁的访问，kill就不起作用，就要在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。`ALTER TABLE tbl_name NOWAIT add column ... `、`ALTER TABLE tbl_name WAIT N add column ...`
## 本期问题
## 同学讨论


# 07 行锁功过：怎么减少行锁对性能的影响？
