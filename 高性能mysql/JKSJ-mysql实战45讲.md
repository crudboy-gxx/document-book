


# 03 事务隔离：为什么你改了我还看不见？
+ 


# 04 深入浅出索引（上）
## 本期问题
+ 重建主键索引不推荐使用删除在新增的方式，要使用`alter table T engine=InnoDB`，这样子就会原地重建表结构。
## 同学讨论


# 05 深入浅出所以索引（下）
+ 回表：回到主键索引树搜索的过程。
+ 覆盖索引：SQL语句只通过索引，就取到了所需要的数据，这个过程就叫做索引覆盖。
  + 覆盖索引直接从索引中获取数据，避免回表二次查询，提升性能。
+ 最左前缀原则：索引从左到右进行匹配。
  + B+树这种索引结构，是按照从做到右的顺序来创建索引树的。
  + 为了使用最左前缀原则，在创建联合索引的时候，就需要根据应用场景来安排索引顺序。
    + 评估的原则就是索引的复用能力，如果通过调整顺序可以少维护一个索引，那么这个顺序就是优先考虑采用的。
    + 如果在有联合索引的情况下，必须单独维护另一个索引，考虑的原则就是空间，单独的建议是占用空间小的。
+ 索引下推：在索引遍历中，对索引包含的字段优先判断，直接过滤到不满足条件的记录，减少回表次数。
## 本期问题
+ 对联合主键索引和InnoDB索引组织表的理解。
## 同学讨论


# 06 全局锁和表锁-给表加个字段怎么有这么多阻碍
+ 全局锁：对数据库实例加锁，使全库进入只读状态，应用场景就是全库逻辑备份。`Flush tables with read lock (FTWRL)`
  + 如果全库支持事务，备份的时候有推荐使用mysqlsump的`-single-transaction`参数，导出前会启动一个事务，来保证拿到一致性视图。如果不是全库支持事务，要使用FTWRL命令。
  + 设置全局只读变量`readonly = true`会导致的问题。1）readonly的值会被用来做其他逻辑，例如一个库是主库还是从库。2）readonly如果客户端发生异常，数据库会一直保持这个状态，导致库不可用。3）readonly对超级管理员是无效。不推荐使用。
+ 表级锁：表级锁有两种方式，一种是显式表锁，一种元数据锁（MDL）。
  + 表锁语法`lock tables … read/write`，
  + MDL锁在访问表时会自动加上，不需要显示使用。对表增删改查操作加读锁，对表做结构变更操作加写锁。
    + MDL机制造成的问题：当变更表的结构时，会加上写锁，其他客户端无论是读锁还是写锁都会被阻塞，这个表的表现就是无法读写。如果客户端有重试机制，超时后会在起一个新的session，那么个库的线程很快就会爆满。
    + 如何给一个小表加字段：首先，如果要变更的表有长事务，无法获取MDL锁，可以将长事务kill掉。如果是热度表会被频繁的访问，kill就不起作用，就要在alter table语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到MDL写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。`ALTER TABLE tbl_name NOWAIT add column ... `、`ALTER TABLE tbl_name WAIT N add column ...`
## 本期问题
## 同学讨论


# 07 行锁功过：怎么减少行锁对性能的影响？
+ 行锁是由各引擎实现的，MyISAM引擎不支持行锁，这意味着并发控制只能使用表锁，同一时间只有一个更新执行，这会影响业务并发。InnoDB支持行锁。
+ 行锁的两阶段锁协议：行锁在需要的时候加上，在事务结束时释放。
  + 理解两阶段锁协议，有助于在业务场景中合理安排事务语句的顺序，将最可能造成锁冲突、最可能影响并发度的锁放到后面，最大程度减少事务之间的锁等待，提升并发度。（实例说明）
+ 当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，会导致这几个线程都进入无线等待状态，造成死锁。
  + 死锁后的两种处理策略：一种是，等待直到超时，超时时间通过`innodb_lock_wait_tinmeout`来设置。另一种是，发起死锁检测，发现死锁后主动回滚锁链条中某一个事务，让其他事务继续执行，将参数`innodb_deadlock_detect`设置为on开启逻辑。
    + 正常情况采取第二种策略，默认是开启的。因为第一种默认时间是50s，如果设置很短，会影响到非死锁的锁等待情况。
    + 死锁检测是非常消耗资源的，每个新来的被堵住的线程都需要判断是否由于自己的加入导致死锁，时间复杂度是O(n)的操作。假如1000并发线程要更新同一行，死锁检测就是100万量级，会占用大量cpu资源。
+ 如何解决这种热点行恒欣导致的性能问题呢？
  + 如果确保业务一定不会出现死锁，可以关掉死锁检测。这样是有风险的，一般业务设计不会考虑死锁，有死锁就回滚，然后业务重试，这是业务无损的。关掉后会出现大量超时的，这是业务有损的。
  + 另一个思路是控制并发度。如果同一行同时最多有10个线程更新，那么死锁检测的成本很低，就不会出现这个问题。直接的想法就是在客户端做并发限制，这样在多客户端的情况下，峰值并发数依然会很大。如果可以改造mysql源码，可以在服务端做，在更新同一行时在进入引擎前排队，这样就不会有大量死锁检测工作了。
  + 可以考虑将修改一行改成逻辑上的多行减少锁冲突。
## 本期问题
问题：怎么删除表的钱1000行。有如下三种方式：第一种，直接执行delete from T limit 10000;第二种，在一个连接中循环执行20次 delete from T limit 500;第三种，在20个连接中同时执行delete from T limit 500。会选择那种方式？
答案：第二种方式较好。第一种是单语句占用时间长，锁的时间也比较长，并且大事务还会导致主从延迟。第三种会造成锁冲突。
## 同学讨论
+ 1、innodb行级锁是通过索引记录实现的，如果更新的列没有创建索引，即使只更新一条记录会锁定整张表吗？ 如果更新的时候增加limit 1，会怎么锁？
  + ？？
+ 2、在不支持行锁的引擎中MDL锁和表锁之间联系
  + 当线程一更新表T上的一行，会加MDL读锁和表写锁；此时线程二要更新另外一行，也要加MDL读锁和表写锁。第二个MDL读锁可以加上，但是表写锁会阻塞，要等第一个线程执行完。


# 08 事务到底是隔离的还是不隔离的？
+ 两种启动事务方式：第一种，使用`begin/start transaction`命令，他会在执行到第一个操作表的语句，事务才真正启动。第二种，使用`start transaction with consistent snapshot`命令，会立即启动一个事务。
+ 