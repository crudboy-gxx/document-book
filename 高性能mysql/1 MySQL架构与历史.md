# 1 MySQL架构与历史

## 1.1 MySQL逻辑架构
MySQL的逻辑架构有三层构成
+ 第一层是客户端，连接、认证、安全等。
+ 第二层是核心服务，查询解析、分析、优化、缓存、内置函数。
+ 第三层是存储引擎，数据的存储和提取。
### 1.1.1 连接管理用户安全性
客户端的每个连接在服务器中拥有一个线程。
### 1.1.2 优化与执行
MySQL会解析查询，并创建内部的数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序、选择合适的索引等。用户使用特殊关键字提示（hint）优化器，影响他的决策过程。也可以使用优化器解释（explain）优化过程中的各个因素，使用户知道服务器是如果进行优化决策的。  
优化器不关心存储引擎，但是存储引擎会对优化查询产生影响。对于查询语句，解析前会检查查询缓存，如果能找到对应查询，服务器就不必执行查询解析、优化和执行的过程，而是直接返回缓存中的结果。

## 1.2 并发控制
只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。从两个层面讨论并发控制，一个是服务器层，另一个是存储引擎层。
### 1.2.1 读写锁
在处理并发读或写时，可以使用共享锁和排他锁来解决问题，也叫读锁和写锁。
### 1.2.2 锁粒度
一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定要修改的部分数据，而非所有资源。锁定的数据量越少，系统的并发程度就越高。但是加锁也是消耗资源的，锁的各种操作，包括获得锁、检查锁是否已解除、释放锁等。系统如果花大量时间管理锁，而不是存储数据，系统性能会受到影响。所谓的锁策略，就是在锁的开销和数据的安全性能之前寻求平衡。
#### 表锁
表锁是最基本的策略，并且是开销最小的策略。写锁会阻塞其他用户，只有在没有写锁时，其他读取的用户才能获取读锁。
#### 行级锁
行级锁可以最大程度的支持并发处理，行级锁只在存储引擎层实现。

## 1.3 事务
事务的特性：原子性、一致性、隔离性、持久性。
### 1.3.1 隔离级别
SQL标准有四种隔离级别，每一级都规定了一个事务所做的修改，哪些在事务内可见，哪些在事务间可见，哪些不可见。较低级别的隔离级别，拥有较好的并发性。  
四种级别：read uncommitted（未提交读）、read committed（提交读）、 repeatable read（可重复读）、serializable（可串行化）。
+ read uncommitted：事务中的修改，即使没有提交也可以读。他不必其他级别好太多，实际中很少用。
+ read committed：大多数数据库默认的级别（mysql不是），事务提交之后才可以读取。他会造成两次查询结果不一致，又叫不可重复度。
+ repeatable read：保证多次读取的结果是一致的。理论上，可重复读无法解决幻读问题，存储引擎的多版本并发控制解决幻读问题。
+ serializable：强制事务串行执行，避免幻读问题。他会在读取每一行数据都加锁，所以可能导致大量超时和锁竞争。实际中很少用。
### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循的现象。当多个事务视图以不同顺序请求锁定资源时，就可能产生死锁。当多个事务同时锁定同一个资源时，也会产生死锁。  
为了解决死锁问题，数据库系统实现死锁监测和死锁超时机制。锁的行为和顺序是和存储引擎相关的。死锁产生有两个原因，有些是真正的数据冲突，有些是存储引擎实现方式导致。死锁发生后，只有部分或完全回滚其中一个事务才能打破死锁。
### 1.3.3 事务日志
事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表数据的时候，只需要修改内存拷贝，然后在把修改行为记录持久在硬盘上的事务日志中，不用每次都持久化到磁盘。
### 1.3.4 MySQL中的事务
MySQL有两种事务型存储引擎：InnoDB和NDBCluster。
#### 自动提交
mysql默认采用自动提交模式，如果不是显示的开始一个事务，则每个查询都会当做一个事务执行提交操作。通过设置autocommit变量来启用或禁用自动提交。
#### 在事务中混合使用存储引擎
mysql的服务层不管理事务，事务是由下层存储引擎实现。会出现在同一个事务中，使用多个存储引起的情况。如果混合使用事务型和非事务性，在正常提交下没问题，但是在需要回滚的情况下，非事务性表无法撤销。
#### 隐式和显式锁定
InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以锁定，在commit或rollback时释放，这是隐式锁。另外InnoDB还支持特定语句的显式锁定。
+ select ... lock in share mode
+ select ... for update

## 1.4 多版本并发控制
mysql的大多数事务型存储引擎实现的都不是简单的行级锁，基于提升性能的考虑，一般都同时实现了多版本并发控制（MVCC）。可以将mcvv理解为行级锁的变种，为了使性能更好，很多情况下避免了加锁操作，实现了非阻塞的读操作，写操作也只锁定必要的行。  
mcvv的实现，是通过保存数据在某个时间点的快照来实现的。不管执行时间多长，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能不一样。不用存储引擎的mcvv实现是不同的，典型的有乐观并发控制和悲观并发控制。
通过InnoDB的简化版来说明MCVV是如何工作的：他是通过在每行记录后面保存两个隐藏列，一个保存行的创建时间，一个保存行的过期时间。这个时间不是实际的时间，而是系统的版本号。每开始一个新的事务，系统版本号都会自动递增。以RR隔离级别为例，看下MCVV如何操作。
+ select：innodb会根据如下两个条件进行查询。1）只查找遭遇当前事务版本的数据行（大于或等于），这样保证了事务读取的行要么是在事务开始之前存在的，要么是自身事务插入或修改的。2）行的删除要么未定义，要么大于当前事务版本号，保证读取的行，在事务开始前未被删除。
+ insert：为新插入的每一行保存当前系统版本号作为行版本号。
+ delete：为删除的每一行保存当前系统版本号作为删除标志。
+ update：为插入一行新记录，保存当前系统版本号作为行版本号，同事保存当前系统版本号到原来的行作为行删除标识。<?>
这样的好处是读不用加锁，性能好。不足点是需要额外的存储空间，要更多的检查和维护工作。

## 1.5 存储引擎
### 1.5.1 InnoDB存储引擎
他被设计用来处理大量的短期事务，短期事务就是大部分情况都是正常提交，很少会回滚。  
InnoDB的数据存储在表空间中，表空间是由InnoDB管理的黑盒子，由一系列数据文件组成。  
innodb通过mcvv支持高并发，实现了四种隔离级别，默认是repeatable read，并且通过间隙锁策略防止幻读。innodb表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过二级索引中必须包含主键，因此，若表上索引多的话，主键尽可能小。  
### 1.5.2 MyISAM存储引擎
#### 存储
#### 特性
#### 压缩表
#### 性能