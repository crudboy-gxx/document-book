# 1 MySQL架构与历史

## 1.1 MySQL逻辑架构
MySQL的逻辑架构有三层构成
+ 第一层是客户端，连接、认证、安全等。
+ 第二层是核心服务，查询解析、分析、优化、缓存、内置函数。
+ 第三层是存储引擎，数据的存储和提取。
### 1.1.1 连接管理用户安全性
客户端的每个连接在服务器中拥有一个线程。
### 1.1.2 优化与执行
MySQL会解析查询，并创建内部的数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序、选择合适的索引等。用户使用特殊关键字提示（hint）优化器，影响他的决策过程。也可以使用优化器解释（explain）优化过程中的各个因素，使用户知道服务器是如果进行优化决策的。  
优化器不关心存储引擎，但是存储引擎会对优化查询产生影响。对于查询语句，解析前会检查查询缓存，如果能找到对应查询，服务器就不必执行查询解析、优化和执行的过程，而是直接返回缓存中的结果。

## 1.2 并发控制
只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。从两个层面讨论并发控制，一个是服务器层，另一个是存储引擎层。
### 1.2.1 读写锁
在处理并发读或写时，可以使用共享锁和排他锁来解决问题，也叫读锁和写锁。
### 1.2.2 锁粒度
一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定要修改的部分数据，而非所有资源。锁定的数据量越少，系统的并发程度就越高。但是加锁也是消耗资源的，锁的各种操作，包括获得锁、检查锁是否已解除、释放锁等。系统如果花大量时间管理锁，而不是存储数据，系统性能会受到影响。所谓的锁策略，就是在锁的开销和数据的安全性能之前寻求平衡。
#### 表锁
表锁是最基本的策略，并且是开销最小的策略。写锁会阻塞其他用户，只有在没有写锁时，其他读取的用户才能获取读锁。
#### 行级锁
行级锁可以最大程度的支持并发处理，行级锁只在存储引擎层实现。

## 1.3 事务
事务的特性：原子性、一致性、隔离性、持久性。
### 1.3.1 隔离级别
SQL标准有四种隔离级别，每一级都规定了一个事务所做的修改，哪些在事务内可见，哪些在事务间可见，哪些不可见。较低级别的隔离级别，拥有较好的并发性。  
四种级别：read uncommitted（未提交读）、read committed（提交读）、 repeatable read（可重复读）、serializable（可串行化）。
+ read uncommitted：事务中的修改，即使没有提交也可以读。他不必其他级别好太多，实际中很少用。
+ read committed：大多数数据库默认的级别（mysql不是），事务提交之后才可以读取。他会造成两次查询结果不一致，又叫不可重复度。
+ repeatable read：保证多次读取的结果是一致的。理论上，可重复读无法解决幻读问题，存储引擎的多版本并发控制解决幻读问题。
+ serializable：强制事务串行执行，避免幻读问题。他会在读取每一行数据都加锁，所以可能导致大量超时和锁竞争。实际中很少用。
### 1.3.2 死锁
死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循的现象。当多个事务视图以不同顺序请求锁定资源时，就可能产生死锁。当多个事务同时锁定同一个资源时，也会产生死锁。  
为了解决死锁问题，数据库系统实现死锁监测和死锁超时机制。锁的行为和顺序是和存储引擎相关的。死锁产生有两个原因，有些是真正的数据冲突，有些是存储引擎实现方式导致。死锁发生后，只有部分或完全回滚其中一个事务才能打破死锁。
### 1.3.3 事务日志
事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表数据的时候，只需要修改内存拷贝，然后在把修改行为记录持久在硬盘上的事务日志中，不用每次都持久化到磁盘。
