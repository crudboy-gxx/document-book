[TOC]

# 泛型

> 本章就是教你如何最大限度地享有泛型的优势，又能使整个使用过程尽可能简单化。

## 26.不要在新代码中使用原生态类型

> Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合； Set 是一个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。使用原生态类型会在运行时导致异常，因此不要使用。 原生态类型只是为了与引人泛型之前的遗留代码进行兼容和互用而提供的。 
>

## 27.消除非受检警告

> 非受检警告很重要，不要忽略它们。 每一条警告都表示可能在运行时抛出ClassCastException 异常。 要尽最大的努力消除这些警告。 如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的 就可以在尽可能小的范围内使用@SuppressWarnings("unchecked"）注解禁止该警告。 要用注释把禁止该警告的原因记录下来。 

## 28.列表优于数组

> 数组和泛型有着截然不同的类型规则。数组是协变且可以具体化的；泛型是不可变的且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。 一般来说，数组和泛型不能很好地混合使用。 如果你发现自己将它们混合起来使用，并且得到了编译时错误或者警告，你的第一反应就应该是用列表代替数组。 

## 29.优先考虑泛型类

> 使用泛型比使用需要在客户端代码中进行转换的类型来得更加安全，也更加容易。 在设计新类型的时候，要确保它们不需要类型转换就可以使用。 这通常意味着要把类做成是泛型的。 只要时间允许，就把现有的类型都泛型化。 这对于这些类型的新用户来说会变得更加轻松，又不会破坏现有的客户端。 

## 30.优先考虑泛型方法

> 泛型方法就像泛型一样，使用起来比要求客户端转换输入参数并返回值的方法来得更加安全，也更加容易 。就像类型一样，你应该确保方法不用转换就能使用，这通常意味着要将它们泛型化。 并且就像类型一样，还应该将现有的方法泛型化，使新用户使用起来更加轻松 ，且不会破坏现有的客户端。

## 31.利用有限制通配符来提升API的灵活性

> 在 API 中使用通配符类型虽然比较需要技巧，但是会使 API 变得灵活得多。 如果编写的是将被广泛使用的类库，则一定要适当地利用通配符类型。记住基本的原则： producer-extends,consumer-super (PECS ） 。 还要记住所有的 comparable 和comparator 都是消费者。

## 32.谨慎并用泛型和可变参数

> 可变参数和泛型不能良好地合作，这是因为可变参数设施是构建在顶级数组之上的一个技术露底，泛型数组有不同的类型规则。 虽然泛型可变参数不是类型安全的，但它们是合法的。如果选择编写带有泛型（或者参数化）可变参数的方法，首先要确保该方法是类型安全的，然后用＠SafeVarargs 对它进行注解，这样使用起来就不会出现不愉快的情况了。 

## 33.优先考虑类型安全的异构容器

> 集合 API 说明了泛型的一般用法，限制每个容器只能有固定数目的类型参数。 你可以通过将类型参数放在键上而不是容器上来避开这一限制。 对于这种类型安全的异构容器，可以用 Class 对象作为键。 以这种方式使用的 Class 对象称作类型令牌 。 你也可以使用定制的键类型。 例如，用一个 DatabaseRow 类型表示一个数据库行（容器），用泛型 Column<T＞作为它的键。 