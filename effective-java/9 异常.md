[TOC]

# 异常

> 充分发挥异常的优点，可以提高程序的可读性、 可靠性和可维护性。 如果使用不当，它们也会带来负面的影响。本章提供了一些关于有效使用异常的指导原则。 

## 69.只针对异常的情况才使用异常

> 异常是为了在异常情况下使用而设计的。不要将它们用于普通的控制流，也不要编写迫使它们这么做的API。 

异常应该只用于异常的情况下；它们永远不应该用于正常的控制流。 如果在不应该使用异常的点使用了异常，可能会造成掩盖BUG，是系统处于非正常状态，并且对排查错误也会造成一定的影响。例如，在循环中捕获数组越界异常。

设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常。例如，Iterator接口有一个态相关的 next 方法，及相应的状态测试方法hasNext。

## 70.对可恢复的异常使用受检异常，对编程错误使用运行时异常

> 对于可恢复的情况，要抛出受检异常；对于程序错误，要抛出运行时异常。不确定是否可恢复，则抛出未受检异常。不要定义任何既不是受检异常也不是运行时异常的抛出类型。要在受检异常上提供方法，以便协助恢复 。 

java提供了三种可抛出结构（Throwable）：受检异常（Exception）、运行时异常（RuntimeException）、错误（Error）。

在什么情况下使用哪种结构，虽然没有一定的标准，但是有一些一般性的原则：

+ 如果期望调用者能适当的恢复，这种情况下就应该使用受检异常。通过抛出受检异常，强迫调用者在一个catch中处理该异常，防止异常传播出去。
+ 用运行时异常表示编程错误。大多数的运行时异常都属于前提违例，没有遵循API的规范。例如数组越界。
+ 实现的所有未受检的抛出结构都应该是 RuntimeException 的子类。
+ 因为受检异常往往指明了可恢复的条件，所以，可以提供一些辅助方法，调用者可以获得一些有助于恢复的信息。例如 Iterator 接口的 hasNext 方法。

## 71.避免不必要地使用受检异常

> 在谨慎使用的前提之下，受检异常可以提升程序的可读性；如果过度使用，将会使 API 使用起来非常痛苦。

如果不希望调用者恢复失败，就应该抛出未受检异常。如果希望调用者可以恢复，就要迫使调用者处理异常，首选返回Optional值，但是返回Optional值，就无法详细说明无法正确计算的原因。

## 72.优先使用标准的异常

不要直接使用Exception、RuntimeException、Throwable、Error。

JavaAPI提供了一组基本的未受检异常，它们满足了绝大多数 API 的异常抛出需求，正常情况下推荐直接重用这些异常，而不是自定义异常。

最经常被重用的异常类型：

| 异常                          | 场合                                  |
| ----------------------------- | ------------------------------------- |
| IllegalArgumentException      | 非 null 的参数值不正确                |
| IllegalStateExceptio          | 不适合方法识l用的对象状态             |
| NullPointerException          | 在禁止使用 null 的情况下参数值为 null |
| IndexOutOfBoundsException     | 下标参数值越界                        |
| UnsupportedOperationException | 对象不支持用户请求的方法              |

## 73.抛出与抽象相应的异常

> 如果不能阻止或者处理来自更低层的异常，一般的做法是使用异常转译，只有在低层方法的规范碰巧可以保证“它所抛出的所有异常对于更高层也是合适的”情况下，才可以将异常从低层传播到高层 。 异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。

更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法称为异常转译。通过异常转换可以获得更详细的信息。如果在进行异常转译的时候，底层的异常对于调试高层异常有帮助的时候，就要使用异常链。

尽管异常转译与不加选择地从低层传递异常的做法相比有所改进，但是也不能滥用它 。如有可能，处理来自低层异常的最好做法是，在调用低层方法之前确保它们会成功执行，从而避免它们抛出异常。

## 74.每个方法抛出的异常都要有文档

> 要为你编写的每个方法所能抛出的每个异常建立文档。这个文档在文档注释中应当采用@throws 标签的形式。 要在方法的 throws 子句中为每个受检异常提供单独的声明。 如果没有为可以抛出的异常建立文档，其他人就很难或者根本不可能有效地使用你的类和接口。 

## 75.在细节消息中包含能捕获失败的信息

为了捕获失败，异常的细节信息应该包含“对该异常有贡献”的所有参数和域的值。例如， IndexOutOfBoundsException 异常的细节消息应该包含下界、上界以及没有落在界内的下标值。  

## 76.努力使失败保持原子性

> 作为方法规范的一部分，它产生的任何异常都应该让对象保持在调用该方法之前的状态。 如果违反这条规则， API 文档就应该清楚地指明对象将会处于什么样的状态。

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被称为具有失败原子性。

有几种途径可以实现这种失败原子性：

+ 在执行操作之前检查参数的有效性。使得在对象的状态给改变之前，先抛出适当的异常 。
+ 整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。
+ 在对象的一份临时拷贝上执行操作，当操作完成之后再用临时拷贝中的结果代替对象的内容。

虽然可以实现失败原子性，但是这并不是人们所期望了，异常通常会被转换，并一直向上抛出。

## 77.不要忽略异常

尽管这条建议看上去是显而易见的，但是它却常常被违反。因此，不要使用空的 catch 块。一旦使用catch块，必须打印错误，这是最基本的要求。

