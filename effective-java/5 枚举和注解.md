# 枚举和注解

## 34.用enum代替int常量和String常量

> 枚举的可读性更好，也更加安全，功能更加强大。许多枚举都不需要显式的构造器或者成员，但许多其他枚举则受益于属性与每个常量的关联以及其行为受该属性影响的方法。只有极少数的枚举受益于将多种行为与单个方法关联，在这种相对少见的情况下，特定于常量的方法要优先于启用自有值的枚举。如果多个（但非所有）枚举常量同时共享相同的行为，则要考虑策略枚举（私有的嵌套枚举 ） 。 

枚举类型没有可以访问的构造器，所以它是真正的 final 类。客户端不能创建枚举类型的实例，也不能对它进行扩展，因此不存在实例，而只存在声明过的枚举常量。 

## 35.用实例域代替序数

> 枚举提供了ordinal()方法返回枚举序列，但是不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

## 36.用EnumSet代替位域

 ？

## 37.用EnumMap代替序数索引

 ？

## 38.用接口模拟可伸缩的枚举

> 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟。 这样允许客户端编写自己的枚举（或者其他类型）来实现接口。 如果 API 是根据接口编写的，那么在可以使用基础枚举类型的任何地方，也都可以使用这些枚举。 

## 39.注解优先于命名模式

？

## 40.坚持使用Override注解

> 如果在你想要的每个方法声明中使用 Override 注解来覆盖超类声明，编译器就可以替你防止大量的错误。

## 41.用标记接口定义类型

> 标记接口和标记注解都各有用处。如果想要定义一个任何新方法都不会与之关联的类型，标记接口就是最好的选择。如果想要标记程序元素而非类和接口，或者标记要适合于已经广泛使用了注解类型的框架，那么标记注解就是正确的选择。  

**标记接口**是不包含方法声明的接口，它只是指明一个类实现了具有某种属性的接口。例如，考虑 Serializable 接口，通过实现这个接口，类表明它的实例可以被序列化。 

