[TOC]

# 通用编程

> 本章主要讨论 Java 语言的细枝末节，包含局部变量的处理、控制结构、类库的用法、各种数据类型的用法，以及两种不是由语言本身提供的机制（反射机制和本地方法）的用法。 最后讨论了优化和命名惯例。 

## 57.将局部变量的作用域最小化

> 将局部变量的作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性 。 

较早的编程语言（C）要求局部变量必须在代码块的开头进行声明，这个习惯应该改正， Java 允许你在任何可以出现语句的地方声明变量。

在第一次使用它的地方进行声明。如果变量在使用之前进行声明，这只会造成温乱，可读性差，并且，过早地声明局部变量不仅会使它的作用域过早地扩展， 而且结束得过晚 。

几乎每一个局部变量的声明都应该包含一个初始化表达式（除了try-catch）。如果没有足够的信息对一个变量进行初始化，那就应该推迟这个声明。

## 58.for-each循环优先于传统的for循环

> 与传统的 for 循环相比，for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。 因此，当可以选择的时候， for-each 循环应该优先于 for 循环。

for-each循环完全隐藏了迭代器和索引变量，避免出错的可能性。

有三种常用情况不能使用迭代器。

+ 如果要删除选定的集合，需要for循环，以调用迭代器的remove方法。java8之后可以使用removeIf方法，省去了迭代过程。
+ 如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量 ，以便所有迭代器或者索引变量都可以同步前进。

## 59.了解和使用类库

> 不要重复发明轮子 。 如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作 。 如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。 

## 60.如果需要精确的结果，避免使用float和double

> 对于任何需要精确答案的计算任务，请不要使用 float 或者 double 。 如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用BigDecimal 。  

float 和 double 类型不适合用于货币计算，因为要让一个 float 或者 double 精确地表示0.1是不可能的。 对于处理货币类型我们可以使用BigDecimal，他可以得到精确的答案。但是，使用BigDecimal也存在缺点，那就是事情麻烦且速度慢。如果对性能要求高，可以使用int和long来处理。

## 61.基本类型优先于装箱基本类型

> 当可以选择的时候，基本类型要优先于装箱基本类型 。 基本类型更加简单，也更加快速 。 如果必须使用装箱基本类型，要特别小心！ 当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱， 当程序进行拆箱时，可能会抛出 NullPointerException 异常 。当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。 

自动装箱（ autoboxing ）和自动拆箱（ auto-unboxing）模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别 。 这两种类型之间真正是有差别的，要很清楚在使用的是哪种类型，并且要对这两种类型进行谨慎的选择。

对装箱基本类型运用==操作符几乎总是错误的。注意不要对两个装箱基本类型使用==。

在什么时候使用装箱类型更合理呢？第一个是作为集合的元素、键和值。第二个是通过反射调用时必须使用装箱类型。最后，实体类中的域推荐使用装箱类型。

## 62.如果其他类型更合适，避免使用字符串

> 如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。 若使用不当字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错 。 经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚合类型。

## 63.了解字符串连接的性能

> 不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要 。 否则，应该使用 StringBuilder 的 append 方法。 另一种做法是使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来 。 

## 64.通过接口引用对象

如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明。如果没有合适的接口存在，完全可以用类而不是接口来引用对象，或者就用类层次结构中提供了必要功能的最小的具体类来引用对象。  

## 65.接口优先于反射机制

> 反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点 。 如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类 。 

反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在。同时，反射也损失了编译时类型检查的优势，并且执行反射的代码非常冗长，性能损失大。

在依赖注入框架和代码分析工具这类复杂的应用中，就需要反射机制。类对于在运行时可能不存在的其他类、方法或者域的依赖性，用反射法进行管理是合理的，但是很少使用 。 

## 66.谨慎的使用本地方法

> 在使用本地方法之前务必三思 。 只有在极少数情况下需要使用本地方法来提高性能 。 如果你必须要使用本地方法来访问底层的资獗，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。 本地代码中只要有一个 Bug 都可能破坏整个应用程序 。 

本地方法是指用本地编程语言（比如 C 或者 C++）来编写的方法 。

## 67.谨慎的进行优化

> 不要费力去编写快速的程序，应该努力编写好的程序，速度自然会随之而来。但在设计系统的时候，特别是在设计 API 、交互层协议和永久数据格式的时候，一定要考虑性能的因素 。 
>
> 当构建完系统之后，要测量它的性能 。 如果它足够快，你的任务就完成了 。 如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分 。 第一个步骤是检查所选择的算法：再多的低层优化也无法弥补算法的选择不当 。必要时重复这个过程，在每一次修改之后都要测量性能，直到满意为止。

 关于优化的建议：

+ 不要为了性能而牺牲合理的结构。应该努力编写好的程序，速度自然会随之而来。
+ 要避免限制性能的决策。当一个系统设计完成之后，其中最难以更改的组件是那些指定了模块之间交互关系以及模块与外界交互关系的组件。这些设计在开发完成后难以改变，也很可能对系统性能限制。
+ 在每次试图做优化之前和之后，要对性能进行测量。
+ 优化的原则就是：不要优化，以及还是不要优化。

## 68.遵守普遍的命名惯例

类

+ 不可实例化的工具类经常用复数名词命名，如 Collectors 或者 Collections 

+ 接口的命名与类相似，例如Collection或Comparator ，或者用一个以 able 或 ible 结尾的形容同来命名，例如 Runnable 、 Iterable、 Accessible 。
+ 枚举命名通常是带有enum后缀，例如 UserTypeEnum。
+ 抽象类命名通常以Abstract开后，例如 AbstractDatasourceProcess。

方法

+ 执行某个动作的方法通常用动词或者动词短谓（包括对象）来命名。
+ 对于返回 boolean 值 的方 法，其名称往往以单词 is 开头。

+ 转换对象类型的实例方法，它们返回的独象的方法，经常被称为toTyp，例如toString或者toArray。
+ 返回视图的方法经常被称为asType，例如asList。
+ 静态工厂的常用名称包括from 、of 、valueOf 、instance 、getInstance 、newInstant、 getTyp、newType。                                 