[TOC]

# 类和接口

## 15.使类和成员的可访问性最小化

> 应该始终尽可能合理地降低程序元素的可访问性。在设计公有API时，应该防止把任何散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外（此时它们充当常量），公有类都不应该包含公有域，如果存在公有静态final域，要确保公有静态final域所引用的对象都是不可变的。 

区分一个组件设计的好不好，唯一重要的因素就是，他对外部组件而言，是否隐匿了内部数据和其他实现细节。设计良好的组件会隐藏所有的实现细节，把API和实现细节清晰的隔离开。然后，组件之间通过API通信。

隐藏信息之所以重要有许多原因，主要的原因就是可以有效的解除系统组件之间的耦合。使得各组件可以独立的进行开发和后续工作，并且有效降低了系统的复杂度，提高代码的可维护性和复用性。

多数情况下，我们在处理业务的时候，是从类与类之间的关系进行考虑和设计，来进行解耦。在此处，我们强调的是使用访问修饰符来隐藏信息，正确的使用访问修饰符对于实现隐藏信息非常关键。如果一个类可以被定义成包级私有，就应该做成包级私有，通过把类定义为包级私有，他实际上就是这个包实现的一部分，而非API的一部分。在后续的版本中，我们如何修改此类都不会对客户端造成影响。

如果一个包级私有的顶层类只有在一个类中使用，就应该使他成为这个类的内部类。这样可以讲此类的可访问降到最小。然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的 API 的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。 

还有一些使用中需要注意的：尽量少用受保护的成员。公共类的域绝对不能成为公有的，及时的final的。

## 16.在公有类中使用公共方法而非公有域 *

> 公有类永远都不应该暴露可变的域。 公有类可以暴露不可变的域，其危害相对来说比较小 。 但有时候会需要用包级私有的或者私有的嵌套类来暴露域，无论这个类是可变的还是不可变的。 
>

如果一个类可以在它所在的包之外进行访问，就不应该允许直接访问该类的成员变量，而是通过公共方法进行访问。

这样充分运用了面向对象的思想，运用封装隐藏对象的属性和实现细节，仅对外提供公共访问方式，隔离变化提高灵活性（该类的成员方法变化后，不会影响客户端使用），便于使用（类的内部状态对外是不可见的，简化客户端的使用）。

存在两种情况，允许公有类中暴露成员变量。

+ 第一种是公有类可以暴露不可变的成员变量。这样做是允许的，但是推荐通过公共方法对外暴露成员变量。

+ 第二种是包级私有或私有嵌套类可以暴露成员变量。这种情况下，因为公共域在包内使用或者类内使用，即使改变了内部数据表示方法，也不会影响客户端使用。

## 17.使可变性最小化

> 在适合的场景下使用不可变类。
>

不可变类是指其实例不能被修改的类，每个实例中包含的所有信息都必须在创建该实例的时候提供，并在对象的整个生命周期内固定不变。

创建一个不可变类需要遵循下面的规则：

+ 不要提供任何会修改对象状态的方法。不给成员变量提供设值方法。
+ 将类声明为final的。这样类就不会被继承。或让类的所有构造器都变成私有的或者包级私
  有的，并添加公有的静态工厂来代替公有的构造器。
+ 声明所有成员变量都是final的，都是私有的。虽然成员变量定义为final即可保证不可变，但是声明私有可以获取更多的灵活性
+ 确保对任何可变组件的互斥访问。如果类中具有指向可变对象的成员变量，必须保证该类的客户端无法获取指向该对象的引用，并且不要从客户端初始化这个成员变量，也不要返回该对象的引用。必要的时候使用深度拷贝。

大多数不可变类都是用了函数方法，函数方法对操作数进行运算并不修改它，而是返回一个新的对象（java8函数式编程）。和函数方法对应的过程或命令的方法，他们会在过程中改变操作数的状态。如果你对函数方法的做法不太熟悉，可能会觉得函数方法不太自然，但是他的不变形会带来很多优点。

不可变类有很多优点：

- 不可变类比较简单。不可变类只有一种状态（被创建时），并且在整个生命周期中不会发生改变。
- 不可变对象本质上是线程安全的，它们不要求同步。
- 不可变对象可以被自由地共享。不用每次都创建实例，从而降低内存占用和垃圾回收的成本。也不需要对对象进行保护性拷贝。

当然不可变类也存在他的缺点，那就是每一个不同的值都需要一个对象。如果执行一个多步骤操作，并且每个步骤都产生一个新的对象，但是只有最后的结果需要保留时，此时性能问题就会显现出来。此时，可以通过一个公有的可变配套类，例如string的可变配套类是StringBuilder。

然而，在实际的应用中，为了提供性能，可以对不可变性有所放松。例如，类的延迟初始化，一个不可变类中存在非final域，在第一次调用类的方法的时候才会初始化，然后将结果方法放到缓存中，再次调用个就会返回缓存。除非有很好的理由要让类成为可变的类，否则它 就应该是不可变的；如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性；除非有令人信服的理由要使域变成是非final的，否则要使每个域都是private final的；构造器应该创建完全初始化的对象 ，并建立起所有的约束关系。 

## 18.复合优先于继承 *

> 继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则 。 只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的 。 即使如此，如果子类和超类处在不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性 。 为了避免这种脆弱性，可以用复合和转发机制来代替继承，尤其是当存在适当的接口可以实现包装类的时候 。 包装类不仅比子类更加健壮，而且功能也更加强大。
>

**继承**（实现继承）是实现代码复用的有力手段，但它并非一定是最好的手段，使用不当会使软件变得脆弱。

我们可以使用**复合**来避免不合理继承带来的问题。复合包含依赖、关联、组合、聚合四种类关系的表现形式。在代码中表现为，不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例。

在包内使用继承很安全，跨包继承是十分危险的，会导致脆弱性。在适合使用复合的地方使用了继承，也会不必要的暴露细节，这种情况就破坏了封装。这样可能在超类变化时对子类造成破坏；也可能造成客户端直接访问超类的细节，从而造成高耦合；更有可能客户有可能直接修改超类，从而破坏子类的约束条件。

什么情况下使用继承？什么情况下使用复合？

我们尽量遵循以下标准：当两个类的关系是is-a时，使用继承；当两个类的关系是has-a时，使用复合。并且复合和**转发机制**来代替继承，尤其是当存在适当的接口可以实现包装类的时候。包装类不仅比子类更加健壮，而且功能也更加强大。

## 19.要么为继承而设计并提供文档说明，要么就禁止继承

> 专门为了继承而设计类是一件很辛苦的工作。 你必须建立文档说明其所有的自用模式，并且一旦建立了文档，在这个类的整个生命周期中都必须遵守。 如果没有做到，子类就会依赖超类的实现细节，如果超类的实现发生了变化，它就有可能遭到破坏。 为了允许其他人能编写出高效的子类，还你必须导出 一个或者多个受保护的方法。除非知道真正需要子类，否则最好通过将类声明为 final，或者确保没有可访问的构造器来禁止类被继承。 
>

## 20.接口优于抽象类 *

> 接口通常是定义允许多个实现的类型的最佳途径 。如果你导出了一个重要的接口，就应该坚决考虑同时提供骨架实现类。 而且，还应该尽可能地通过缺省方法在接口中提供骨架实现，以便接口的所有实现类都能使用。也就是说，对于接口的限制，通常也限制了骨架实现会采用的抽象类的形式。
>

我们考虑下为什么使用抽象类，首先抽象类不能被实例化，所以抽象类就是被继承使用，为子类提供了公用实现方法和抽象模板方法。java8之后，接口引入了默认方法，这种机制也允许为某些实例方法提供实现。所以使用抽象类可以完成的，接口都可以完成，并且使用接口还拥有更多的灵活性，可以实现多继承。

当然，抽象类在一些场景下，还是有意义的。首先接口中不允许存在非公有静态成员，并且我们不能给不受控制的接口添加缺省方法。

但是，通过使用对接口提供一个抽象的骨架实现类，可以把接口的优点和抽象类的优点结合起来。接口负责定义类型方法和缺省方法，而骨架实现类负责实现除了基本类型方法之外的非基本类型方法，这就是模板方法模式。骨架实现类的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所特有的严格限制 。此外，骨架实现类仍然有助于接口的实现。 实现了这个接口的类可以把对于接口方法的调用转发到一个内部私有类的实例上，这个内部私有类扩展了骨架实现类。 这种方法被称作模拟多重继承。

如果基本方法和缺省方法覆盖了接口，你的任务就完成了，不需要骨架实现类了。否则，就要编写一个类，声明实现接口，并实现所有剩下的接口方法 。 这个类中可以包含任何非公有的域，以及适合该任务的任何方法 。 

## 21.为后代设计接口

建议尽量避免利用缺省方法在现有接口上添加新的方法，除非有特殊需要，但就算在那样的情况下也应该慎重考虑：缺省的方法实现是否会破坏现有的接口实现。

## 22.接口只用于定义类型 *

> 接口应该只被用来定义类型， 它们不应该被用来导出常量。
>

当类实现接口时，接口就充当可以引用这个类的实例的类型（type ）。因此，类实现了接口，就表明客户端可以对这个类的实例实施某些动作。 为了任何其他目的而定义接口是不恰当的。 

有一种接口被称为常量接口，它不满足上面的条件。 这种接口不包含任何方法，它只包含静态的 final 域， 每个域都导 出一个常量。 使用这些常量的类实现这个接口，以避免用类名来修饰常量名。**常量接口模式是对接口的不良使用**。

## 23.类层次优于标签类

> 标签类很少有适用的时候。 当你想要编写一个包含显式标签域的类时，应该考虑一下，这个标签是否可以取消，这个类是否可以用类层次来代替。当你遇到一个包含标签域的现有类时，就要考虑将它重构到一个层次结构中去。
>

## 24.静态成员优于非静态成员类 *

> 共有四种不同的嵌套类（成员内部类、局部内部类、匿名内部类、静态成员内部类），每一种都有自己的用途。 如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合放在方法内部，就应该使用成员类。 如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。 假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类；否则，就做成局部类。 
>

成员内部类可以访问外部类的所有成员，包括私有的。成员内部类的每个实例都隐含的与外围实例相关联，所以，成员内部类必须在外部类实例的基础上创建实例。静态成员类优于非静态的原因也是在此，静态成员类不会保存指向外围对象的引用，减少时间和空间的消耗，见 HashMap。

如果嵌套类的实例可以在它外围类的实例之外独立存在，或嵌套类不要求访问外围实例 ，这个嵌套类就必须是静态成员类。

匿名内部类的应用比较多的是实例化一个函数式接口，java8之后Lambda表达式替代了匿名内部类。

局部内部类是使用最少的类，能够使用匿名匿名内部类，就不使用局部内部类。

一般说来，内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外国类的对象。所以可以认为内部类提供了某种进入其外围类的窗口。 如果说，接口解决了多重继承的问题，那么，内部类使得多重继承更加完善。

## 25.限制源文件为单个顶级类

