# 本章内容
如何使用Lambda表达式重构代码
Lambda表达式对面向对象的设计模式的影响
Lambda表达式的测试
如何调试Lambda表达式和StreamAPI的代码
***
# 核心问题
<font color="red" size="5">
1.改善代码可读性和灵活性具体措施式什么<br/>
2.如何测试Lambda表达式<br/>
3.如何调试Lambda表达式<br/>
</font>

***
# 概述
通过前面章节，我们了解了Lambda表达式和StreamAPI的强大。如果创建的是全新的项目，我们可以将新特性轻松应用到项目上。但是，很多情况是没有机会从头开始新的项目，我们将面对用老java编写的遗留代码。因此本章就是要讨论在遗留代码上使用新特性的问题。
+ 我们会介绍几种方法，帮助进行代码的重构，以适配Lambda表达式，让我们维护的代码具有更好的可读性和灵活性。
+ 我们也会讨论目前流行的集中设计模式，包括策略模式、模板方法模式、观察者模式、责任链模式、工厂模式，在结合Lambda表达式之后变得更简洁的情况。
+ 最后，介绍如何测试和调试使用Lambda表达式和StreamAPI的代码。
***
# 8.1 为改善可读性和灵活性改善代码
从开篇就强调，使用Lambda表达式，可以写出更灵活、更简洁的代码。
更简洁体现在：
+ Lambda与匿名内部类的对比上，Lambda可以更紧凑的方式描述程序的行为。
+ 如果希望一个既有的方法作为参数传递给另一个方法，那么方法引用是我们推荐的方法，利用这种方式可以写出更简洁的代码。

更灵活体现在：
+ 应对变化的需求时，行为参数化的方式，可以依据传入的参数，动态的执行相应的行为。

本小节通过示例方式，展示如何运用前面介绍的**Lambda表达式、方法引用、Stream接口等**来重构遗留的代码，改善代码的可读性和灵活性。
## 8.1.1 改善代码的可读性
我们很难定义什么是好的可读性，因为这可能非常主观。通常的理解是，“别人理解这段代码的难易程度”。改善可读性意味着你要确保你的代码要非常容易的被人理解和维护。

java8的新特性也可以帮助提升代码的可读性：
+ 使用java8，可以减少冗长代码，让代码更易理解。
+ 通过方法引用和StreamAPI，让代码更直观。

三种简单的重构：
+ 用Lambda表达式取代匿名类。
+ 用方法引用重构Lambda表达式。
+ 用StreamAPI重构命令式的数据处理。
## 8.1.2 从匿名类到Lambda表达式的转换
来看一个简单的示例：
~~~
// 匿名类
Runnable r1 = new Runnable(){
	public void run(){
		System.out.println("Hello");
	}
};
// Lambda表达式
Runnable r2 = () -> System.out.println("Hello");
~~~
将匿名类转换为Lambda表达式并不都是像上例一样简单，某些情况下，这个转换是一个复杂的过程。
+ 首先，匿名类和Lambda表达式中的this和super的含义不同，匿名类中代表自身，Lambda中代表的是包含类。
+ 其次，匿名类可以屏蔽包含类的变量，Lambda不能（他们会导致编译错误）。
+ 最后，在涉及重载的上下文里，将匿名类转换为Lambda可能更加晦涩。实际上，匿名类的类型是在初始化是确定的，而Lambda的类型取决于他的上下文。
~~~
int a = 10;
// 这段代码出现编译错误！！！
Runnable r1 = () -> {int a = 2;System.out.println(a);};
~~~
## 8.1.3 从Lambda表达式到方法引用的转换
为了进一步改善代码可读性，请使用方法引用代替Lambda表达式（可以替换的情况下），因为方法名更能直观的表示代码的意图。为此，我们可以将Lambda表达式提取到一个单独的方法中。例如：
~~~
// 转换前
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
	menu.stream()
		.collect(
			groupingBy(dish -> {
			if (dish.getCalories() <= 400) return CaloricLevel.DIET;
			else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
			else return CaloricLevel.FAT;
			}));
// 转换后，将Lambda表达式提取成Dish的一个单独方法getCaloricLevel
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
menu.stream().collect(groupingBy(Dish::getCaloricLevel));
~~~
除此之外，我们还应尽量使用静态辅助方法，比如comparing、maxBy。这个方法的设计之初就考虑了结合方法引用一起使用。例如：
~~~
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
inventory.sort(comparing(Apple::getWeight));
~~~
此外，很多通用的归约方法，比如sum、maximum，都有内建的辅助方法可以和方法引用结合使用。
~~~
int totalCalories = menu.stream().map(Dish::getCalories).reduce(0, (c1, c2) -> c1 + c2);
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
~~~
## 8.1.4 从命令式的数据处理切换到Stream
建议将所有使用迭代器这种数据处理模式处理集合的代码都转换成StreamAPI的方式。因为Stream有很多的优势，他可以更清楚的表达数据处理的意图，他可以通过短路和延迟载入进行并行处理。

将命令式的代码结构转换为StreamAPI的形式是个困难的任务，因为我们需要考虑控制语句，比如break、continue、return，并选择使用恰当的流操作。
## 8.1.5 增加代码的灵活性
我们介绍了Lambda表达式有利于行为参数化，你可以使用不同的Lambda表示不同的行为，并将他们作为参数传递给函数去执行。这种方式可以从容的面对需求变化。现在，来看看哪些模式可以马上应用到你的代码中，让你享受Lambda表达式带来的便利。
### 1.采用函数接口
首先，必须意识到，没有函数接口，就无法使用Lambda表达式。因此，需要在代码中引入函数接口。但是在什么情况下使用它们呢？这里我们介绍两种通用的模式，可以依照这两种模式重构代码，利用Lambda表达式带来的灵活性，它们分别是： 有条件的延迟执行和环绕执行。
### 2.有条件的延迟执行
如果你发现你需要频繁地从客户端代码去查询一个对象的状态（比如前文例子中的日志器的状态），只是为了传递参数、调用该对象的一个方法（比如输出一条日志），那么可以考虑实现一个新的方法，以Lambda或者方法表达式作为参数，新方法在检查完该对象的状态之后才调用原来的方法。你的代码会因此而变得更易读（结构更清晰），封装性更好（对象的状态也不会暴露给客户端代码了）。
### 3.环绕执行
如果你发现虽然你的业务代码千差万别，但是它们拥有同样的准备和清理阶段，这时，你完全可以将这部分代码用Lambda实现。这种方式的好处是可以重用准备和清理阶段的逻辑，减少重复多余的代码。
***
# 8.2 使用Lambda重构面向对象的设计模式
》》》
***
# 8.3 测试Lambda表达式
大多数时候，我们进行的程序开发工作的要求并不是编写优美的代码，而是编写正确的代码。

示例：》》》
## 8.3.1 测试可见Lambda函数的行为
Lambda并无函数名，因此对代码中的Lambda表达式进行测试实际上比较困难，因为无法通过函数名进行调用。有些时候，你可以借助某个字段访问Lambda函数，这种情况，你可以利用这些字段，通过它们对封装在Lambda函数内的逻辑进行测试。因为Lambda表达式会返回一个函数式接口的实例，由此，可以测试实例的行为。

示例：》》》
## 8.3.2 测试使用Lambda的方法的行为
但是Lambda的初衷是将一部分逻辑封装起来给另一个方法使用。从这个角度出发，你不应该将Lambda表达式声明为public，它们仅是具体的实现细节。相反，我们需要对使用Lambda表达式的方法进行测试。
## 8.3.3 将复杂的Lambda表达式分到不同的方法
可能你会碰到非常复杂的Lambda表达式，包含大量的业务逻辑。你无法在测试程序中引用Lambda表达式，这种情况该如何处理呢？一种策略是将Lambda表达式转换为方法引用（这时你往往需要声明一个新的常规方法）。
## 8.3.4 高阶函数的测试
接受函数作为参数的方法或返回一个函数的方法更难测试。如果一个方法接受Lambda表达式作为参数，你可以采用的一个方案是使用不同的Lambda表达式对它进行测试。如果被测试方法的返回值是另一个方法，你可以按照我们之前处理Comparator的方法，把它当成一个函数接口，对它的功能进行测试。
***
# 8.4 调试
## 8.4.1 查看跟踪栈
程序失败时，你会得到它的栈跟踪，通过一个又一个栈帧，你可以了解程序失败时的概略信息。换句话说，通过这些你能得到程序失败时的方法调用列表。这些方法调用列表最终会帮助你发现问题出现的原因。不幸的是，由于Lambda表达式没有名字，它的栈跟中可能很难分析。

这些表示错误发生在Lambda表达式内部。由于Lambda表达式没有名字，所以编译器只能为它们指定一个名字。如果你使用了大量的类，其中又包含多个Lambda表达式，这就成了一个非常头痛的问题。即使你使用了方法引用，还是有可能出现ಖ无法显示你使用的方法名的情况。

总的来说，我们需要特别注意，涉及Lambda表达式的栈跟踪可能非常难理解。
## 8.4.2 日志调试
假设你试图对流操作中的流水线进行调试，该从何入手呢？在流的最后使用foreach是否可行呢。不幸的是，一旦调用forEach，整个流就会恢复运行。

到底哪种方式能更有效地帮助我们理解Stream流水线中的每个操作（比如map、 filter、 limit）产生的输出？这就是流操作方法peek大显身手的时候。peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。但是它不像forEach那样恢复整个流的运行，而是在一个元素上完成操作之后，它只会将操作顺承到流水线中的下一个操作。
***
# 8.5 小节
+ Lambda表达式能够提升代码的可读性和灵活性。
+ 如果你的代码中使用了匿名类，尽量用Lambda表达式替换它们，但是要注意二者间语义的微妙差别，比如关键字this，以及变量隐藏。
+ 跟Lambda表达式比起来，方法引用的可读性更好 。
+ 尽量使用Stream API替换迭代式的集合处理。
+ Lambda表达式有助于避免使用面向对象设计模式时容易出现的僵化的模板代码，典型的比如策略模式、模板方法、观察者模式、责任链模式，以及工厂模式。
+ 即使采用了Lambda表达式，也同样可以进行单元测试，但是通常你应该关注使用了Lambda表达式的方法的行为。
+ 尽量将复杂的Lambda表达式抽象到普通方法中。
+ Lambda表达式会让栈跟踪的分析变得更为复杂。
+ 流提供的peek方法在分析Stream流水线时，能将中间变量的值输出到日志中，是非常有用的工具。