# 5 分解单块系统

本章将要讨论如何将已有的单体系统分解为服务。

## 1 关键是接缝

单体应用最大的问题就是耦合性的问题，由于相关的代码、不相关的代码都在一起，松耦合这一说也不复存在。修改代码后很难保证不对其他功能造成影响，同时部署的时候需要部署整个系统。

此处接缝就是可以理解为限界上下文的边界，因为在限界上下文内部是高内聚，边界是低耦合的。因此我们首先要识别限界上下文，定义边界，然后抽取代码。

## 2 分解MusicCorp 

现在有一个巨大的后台单块服务， 其中包含了 MusicCorp 在线音乐系统所需要的所有行为。 首先，我们应该识別出组织中的高层限界上下文，然后尝试理解这个单块系统能够被映射到哪些限界上下文中。

开始我们识别出四个限界上下文：

+ 产品目录：与正在销售的商品相关的元数据。
+ 财务：账户、 支付、 退款等项目的报告。
+ 仓库：分发客户订单、 处理退货、 管理库存等。
+ 推荐：该系统的算法正在申请专利。 它是革命性的推荐系统， 代码非常复杂。 

下面我们来进行分解。首先我们根据上下文来定义包，然后将代码都移动包中，如果有剩下的代码很可能是我们遗漏的限界上下文。在这个过程中，我们会分析代码这些包之间的依赖。*如果发现仓库包依赖于财务包中的代码， 而真实的组织中并不存在这样的依赖， 那么就需要看看到底是什么问题， 并想办法解决它。*

## 3 分解单块系统

决定把单块系统变小是一个好的开始，建议使用增量的方式来分解。这样，能保证我们在进行中学习微服务，同时也能限制出错的影响。

我们已经识别了接缝，下面我们应该抽离哪个系统呢？最好考虑下抽取哪个系统的收益最大，而不是为了抽取而抽取。

+ 改变的速度
+ 团队结构
+ 安全
+ 技术

## 4 杂乱的依赖

我们已经识别出列一些接缝，另一个要考虑的问题就是，当前代码与剩余代码之间的依赖问题。我们抽取出来的代码应该尽量少的被其他组件依赖。如果代码依赖杂乱，往往是因为数据库造成的。

## 5 数据库

前面我们说明了，使用数据库做服务间的集成，是非常不建议的。代码依赖杂乱的源头是数据库导致的，但是想从数据库找到接缝，是一个棘手的问题。

## 6 找到问题的关键

按照前面的操作，我们的代码已经按照限界上下文被组织到相应的包中。对于数据库访问的代码来说，我们也需要将仓储层的代码分成几部分。将数据库访问的代码和功能放到同一个上下文中，有助于我们理解哪些功能用到了哪些表。

当我们在分离数据库表的时候，可能会发现不同上下文的表之间存在约束。我们如何切断这样的连接呢？当遇到一个表被多个上下文使用的场景应该怎么处理呢？

## 7 例子：打破外键关系

将系统拆分成两个服务定的过程中，遇到两个服务间存在表外键关联的时候，我们应该将原来采用数据库查询的方式进行转换，通过使用API的方式进行访问数据。这样就可能变成查询两次数据库，有人会取担心性能问题，这个变慢可以在接受范围之内就没有问题。

另一个问题是，怎么样处理外键？我们只能舍弃外键，把这个约束从数据库层面拿到代码层面去解决。这就意味着我们需要做跨服务的一致性检查，或者周期性的触发清理任务。采用哪种方式通常是由具体的业务来决定，而不是技术来决定。

## 8 例子：共享静态数据

如果是一个基本不怎么变化的表，并且会被很多服务使用，我们应该怎么处理呢？

+ 把这些静态数据放到代码中，不如放到配置文件或者枚举类中。虽然这样数据一致性的问题还是存在，但是这样还是比较合理的。
+ 把静态文件放到一个单独的服务中。当遇到比较复杂的场景可以做，比如字典或系统权限。

这两个的选择还是依据场景的复杂度来选择，大部分情况下使用第一种就可以满足需求。

## 9 例子：共享数据

共享的可变数据对于分离系统来说是一个大麻烦。

考虑这样一个复杂的场景，一个表中存储了多个服务的信息，多个服务会向同一张表中写入或读取数据，这种情况下如何做分离呢 ？这种情况非常常见，造成这个情况的原因很明确，就是领域概念不是在代码中建模，实在数据库中隐式的建模。

这个时候我们需要将隐式的建模具体出来，将其他服务依赖的信息，重新建模为一个服务，为其他服务通过接口提供信息。

## 10 例子：共享表

将共享的表进行拆分，通常没有什么问题。

## 11 重构数据库

我们已经找到了程序的接缝，按照上下文进行的分组，并且找到了数据库的接缝，尽量对其进行了分离。然后呢，我们需要将单块的系统变成两个服务，并且各自的服务有各自的数据库吗？事实上，我们推荐先分离数据库结构，暂时不对服务进行分离。

表结构分离之后，对数据的查询次数可能会增加。另外，分成两个表结构可能会破坏事务的完整性，这会对程序造成巨大的影响。但是先分离数据结构不分离服务的好处在于，可以随时选择回退这些选择或是继续进行，而不影响服务的消费者。当我们对分离数据库满意后，可以进行服务的分离。

## 12 事务边界

事务时很有用的，他们保证一次操作要么都发生，要么都不发生。当我们使用单块表结构的时候，所有的创建或者更新都在一个事务边界内完成。分离了数据库就没有了这个好处，那么，我们如何解决不用服务之间的事务问题呢？

### 12.1 再试一次

在处理跨服务的事务的时候，我们可以采用事件机制。当服务A插入成功后发布事件，事件发布到队列或日志中，然后由服务B消费这个事件。这样操作是合理的，但是需要服务B失败后能修复这个问题，使其保持一致性。

我们将这种形式称作最终一致性。相对于事务来保持一致性，最终一致性可以接受在未来的某个时间达到一致性。

### 12.2 终止整个操作

另一个选择时终止整个操作，将系统重置到一致的状态。这种处理方式，就需要我们提供一个**事务补偿机制**，来抵消之前的操作。补偿失败了怎么办？我们是不是在后台有一个清除这些不一致状态数据的任务呢？其实这种补偿机制非常难以理解和控制。

### 12.3 分布式事务

手动编配事务补偿非常难以操作，一种替代方案是分布式事务。分布式事务会跨越多个服务，然后使用一个叫**事务管理器**的工具进行统一编配其他底层系统中运行的事务。

### 12.4 抉择

第一选择是使用最终异质性，我们将考虑是不是能将分布式事务简单的放到本地事务中。

如果一定要保持一致性，一定要小心的使用分布式事务。<font color="red">分布式事务讲的比较简单</font>。

## 13 报告

当我们对服务进行分离的时候，数据的存储也会进行分离，但是这样的操作我们在统计报表的时候很可能就有问题，因为报表通常来自多个服务的数据。

## 14 报告数据库

如果把信息存储到不同的系统中，又该如何处理呢？有什么办法可以把所有的数据放在一起生成报告呢？ 是否能够同时找到一些方法来消除与标准的报告数据库模型相关的那些缺点呢？ 

接下来看集中实践。

### 15 通过服务调用来获取数据

简单的报表可能直接通过API来获取数据，但是对于跨多个服务或者使需要大数据量的时候，则并不是好的选择。并且在本地保存数据也是十分危险的，因为我们不知道数据是否被修改。

虽然可以使用第三方工具，定期把数据拉取到sql数据库中，但是着也是存在问题。主要是不同的服务提供的API可能不满足场景。

### 16 数据导出

和报表系统拉取的方式相比，我们可以使用把数据推送的方式。

## 17 事件数据导出

每个微服务可以在其管理的实体发生变化的时候发送事件，推荐报表系统编写自己的订阅器把数据导入到报表数据库中。这样可以消除消除与源微服务底层数据库的耦合，并且时效性更高。

## 18 数据导出的备份

## 19 走向实时

## 20 修改的代价

贯穿始终，我们一直在强调做小的、增量修改。这样可以帮助我们理解修改造成的影响，帮助我们更好的消除错误的代价。

在同一个代码库中移动代码的代价相当小，但是分割数据的难度就要大的多，而且退回也十分困难。另外，解开服务间的耦合或者重写一个多消费者在使用的API，都是非常巨大的工作。巨大的工作会带来巨大的风险。

## 21 理解根本原因

我们讨论了如何将大服务拆解成小服务，但是这些大服务是如何产生的呢？需要理解的是服务一定会慢慢变大，直至大到需要拆分。我们希望我们的架构随着时间的推移增量地进行变化，关键是在拆分变得十分昂贵之间，意识到需要做这个拆分。

尽管我们都知道小服务比大服务更合适，但是我们依旧逐渐将服务变大，这是为什么呢? 

知道从哪开始是解决方案重要的部分，本章内我们进行了讨论。但是另一个问题是拆分服务带来的代价，拆分做起来并不简单。

## 22 小结

我们通过寻找服务边界把系统分解开来， 且这可以是一个增量的过程。 在最开始就要养成及时寻找接缝的好习惯， 从而减少分割服务的代价， 这样才能够在未来遇到新需求时继续演化我们的系统。 

那么现在可以开始对服务进行分割了， 但是我们也引入了一些新的问题： 需要部署上线的组件变多了！ 