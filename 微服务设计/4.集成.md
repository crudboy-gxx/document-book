# 4.集成
集成是微服务相关技术中最重要的一个，做的好的话，可以保持服务的自治性，以及独立的修改和发布他们。

## 1 寻找理想的集成技术

微服务通信方式有很多种，SOAP、REST，应用这些通信方式来解决什么样的问题呢？下面来看下选择服务间集成的一些技术指导。

### 1.1 避免破坏性修改

有时候服务的修改会导致消费者的修改，我们希望选用的技术尽量避免这一情况的发生。

### 1.2 保证API的技术无关性

我们不应该选择对微服务具体实现技术有限制的集成方式。

### 1.3 使你的服务易于消费方使用

理想模式下，消费方可以使用任何技术来实现集成。提供一个客户端库可以简化集成方式，对于消费者来说更加方便，但是会造成耦合的增加。

### 1.4 隐藏内部实现细节

我们不希望消费方与服务的具体细节绑定在一起，这样会增加耦合性，导致破坏性修改。因此，倾向于暴露内部细节的技术不应该被采用。

## 2 为用户创建接口

创建一个真的例子：MusicCorp

创建客户这个业务， 乍一看似乎就是简单的 CRUD 操作， 但对于大多数系统来说并不止这些。 添加新客户可能会触发一个新的流程， 比如进行付账设置、 发送欢迎邮件等。 而且修改或者删除客户也可能会触发其他的业务流程。 

## 3 共享数据库

 共享数据库的好处就是简单，集成起来也快速，但是这种方式只会带来更多的麻烦。

1.使得外部系统可以查看到内部的细节，与其绑定在一起。如果增加或者修改的表的结构的话，消费方很可能就无法正常工作。为了不影响其他业务，我们必须小心的修改表结构，通常这种修改只能通过大量的回归测试来保证正确性。

2.使得消费方与具体的技术绑定在一起。正如上面说到的，隐藏细节非常重要，这样才能让服务有一定的自治性，从而轻松的修改内部的实现。

3.造成重复的行为和代码冗余。数据库额可以很好的共享数据库，但是无法共享行为。

## 4 同步与异步

让我们在讨论具体的技术前，讨论下服务之间的通信时同步还是异步，在一定程度上绝对了技术的选型。

同步和异步各有应用场景，低延迟且对结果反馈及时性不高可以使用异步，结果反馈及时性高需要使用同步。异步技术的复杂性更高，并且两种技术的实现也略不同，同步多采用请求/响应，异步多采用基于事件方式。

基于事件的协作方式耦合性更低，客户端发布一个事件，他并不关心谁会对这个事件做出响应，这样就可以在不影响客户端的情况下对该事件添加新的订阅者。

## 5 编排与协同

当我们对复杂的业务建模时，就要处理跨服务的业务流程，考虑到具体的实现，我们可以采用编排或协同这两种架构风格。

编排：我们会依赖一个中心，来驱动整个流程。

协同：我们会告知各个服务的各自职责。

让我们来看看在MusicCorp中创建用户时发生了什么： (1)在客户的积分账户中创建一条记录。(2)通过邮政系统发送一个欢迎礼包。(3)向客户发送欢迎电子邮件。

考虑下对于这个流程来说，编排的解决方案会是什么样子的。 可能最简单的方式就是让客户服务作为中心大脑。 在创建时它会跟积分账户、 电子邮件服务及邮政服务通过请求 / 响应的方式进行通信。  编排的好处是可以对每个步骤进行跟踪，如果是同步的方式，可以立即知道每一步执行的结果。编排的缺点是中心服务承担了太多职责，会成为网状结构的中心枢纽和很多逻辑的起点。

如果使用协同，可以仅仅从客户服务中使用异步的方式触发一个事件， 该事件名可以叫作“客户创建”。 电子邮件服务、 邮政服务及积分账户可以简单地订阅这些事件并且做相应处理。协同的好处就是降低服务间的耦合，缺点是没有明显的业务流程视图。**这就需要我们做额外的工作来监控流程**。

通常来讲， 我认为使用协同的方式可以降低系统的耦合度， 并且你能更加灵活地对现有系统进行修改。 但是， 确实需要额外的工作来对业务流程做跨服务的监控。 所以更倾向与这种方式。实际的问题需要考虑一下几个因素。同步调用比较简单， 而且很容易知道整个流程的工作是否正常。 如果想要请求 / 响应风格的语义， 又想避免其在耗时业务上的困境， 可以采用异步请求加回调的方式。使用异步方式有利于协同方案的实施， 从而大大减少服务间的耦合， 这恰恰就是我们为了能独立发布服务而追求的特性。 

## 6 RPC

。。。暂时不考虑这种技术

## 7 REST

这里我们只考虑使用REST更好的解决集成问题。其中重要的一点是资源的概念。一个资源的对外展示和内部存储方式之间是没有耦合的。另外REST并没有指定底层协议，但是HTTP是最常用的。

### 7.1 REST和HTTP

HTTP的动词很好的契合REST，get获取资源、post创建资源。

并且HTTP周边有一个大的生态系统，其中包含很多支撑工具和技术。 比如 Varnish 这样的HTTP 缓存代理、 mod_proxy 这样的负载均衡器 、大量针对 HTTP 的监控工具等 。

### 7.2 超媒体作为程序状态的引擎

REST用来避免客户端和服务端耦合的原则之一是超媒体作为程序状态的引擎。超媒体的概念是，有一块内容，该内容包含了指向其他内容的链接。他背后的想法是客户端应该与服务端通过那些指向其他资源的链接进行交互，而这些交互可能造成状态转移。

举个例子说明，作为一个客户端， 我不需要知道购买专辑的 URI，只需要访问专辑资源， 找到其购买链接， 然后访问它即可。 购买链接的位置可能会改变， URI 也可能会变， 该站点甚至可以发送给我额外的信息， 但是作为客户端不用在意这些。 这就使得客户端和服务端之间实现了松耦合。 这样底层细节就被很好地隐藏起来。我们可以随意改变链接的展现形式， 只要客户端仍然能够通过特定的协议找到它即可。

使用这些链接来对客户端和服务端进行解耦， 从长期来看有着很显著的好处， 因为你不需要一再调整客户端代码来匹配服务端的修改。 通过使用这些链接，客户端能够自行获取相关 API，这对于实现新客户端来说非常方便。 

### 7.4 过多的约定

在时间RESTFul WEB的时候，我们应该避免直接将存储的数据暴露给消费者，这种方式会带来内在的耦合性。

我们应该先设计外部接口，等到外部接口稳定之后，在实现微服务内部的数据持久化。这样做可以保证接口时消费者的需求驱动出来的，从而避免数据存储方式对外界造成的影响。

### 7.5 基于HTTP的REST的缺点

当我们在使用客户端库的时候，可能又会回到PRC的思路上去，我们创建一个共享库，在客户端和服务端之间共享代码，这样时非常危险的。

性能可能会有问题。对于低延迟通信场景，WebSockets更加高效。当前还有一些其他场景，可能需要其他协议进行处理更加合适。

## 8 实现基于事件的异步协作方式

### 8.1 技术选择

主要有两个方面需要考虑：微服务发布事件机制和消费者接收事件机制。

通常来讲，**RabbitMQ**队列中间件是一种可靠的方式，还可以使用支持http协议的中间件**ATOM**。

在使用中间件的时候，尽量保证中间件的简单，把业务放到自己的服务中。

### 8.2 复杂性

事件驱动和异步编程可以保持系统的低耦合和扩展性，但是这种方式也会带来一定的复杂性。我们需要确保各个流程有很好的监控机制，保证我们对请求的跟踪。

我们要尽量避免灾难性故障转移，以及避免消费者竞争。

## 9 服务即状态

当消费者想要对客户服务进行修改时，他会向客户服务发送修改请求，客户服务判断是否接收该请求的修改。客户服务控制了与客户生命周期相关的事件，如果除了客户服务之外可以修改客户的地方，那么就是去了内聚性。

把关键领域的声明周期显式的建模出来很有必要，我们不但可以在唯一的地方处理状态冲突，而且可以在这些状态变化的基础上封装一些行为。

## 10 响应式扩展？

RxJava，可以把多个调用的结果组装起来，并在此基础上执行操作。

当你需要做一些基于多个服务调用的操作时， 尝试一下适合你所选用技术栈的响应式扩展。 你会惊讶地发现它让你的代码变得非常简单 

## 11 微服务中的DRY和代码复用的危险

如果在系统中，有相同的代码在做同样的事情，就会降低系统的可维护性，所以我们尽量避免复制代码。取代复制代码的一种方式是创建共享库，将重复的代码放到共享库中，来得到重用性比较好的代码。**但是这种方式在微服务中是比较危险的**，我们在使用微服务的时候，尽量降低服务和消费者的耦合度，否则对服务的改动可能会引起消费者的改动。跨服务的共享代码就可能引入耦合，我们不会在服务之间共享代码，而是将代码复制到每个新的服务中，以防止耦合的发生。<font color="red">这样还是存在耦合，复制代码也避免不了耦合，如果服务的代码改动，那客户端复制过去的代码是不是也得改动呢？</font>

建议：在服务内部不要违反DRY，在服务之间可以适当违反DRY。因为服务之间引入耦合比代码的重复可能带来更多的问题。

### 客户端

很多团队会为服务开发一个客户端，客户端可以简化对服务的使用，可以避免不同消费者存在与服务交互的重复代码，同时也可以保持系统的伸缩性和可扩展性（客户端会担任服务发现的工作）。我们在使用客户端的时候唯一要注意的就是，**不要将服务相关的逻辑放到客户端库中**，这很容易发生，也很重要。最后要保证由客户端来决定客户端库的升级，这样才能保证每个服务独立于其他服务进行发布。

是否使用客户端，需要从多个角度去考虑。

## 12 按引用访问

服务之间**如何传递领域实体的相关信息**是一个指的讨论的话题，一个服务应该包含领域实体的全生命周期的相关操作。在遵守客户端的原则的情况下，如果想对客户做改动，就要向客户服务发送请求。因为客户服务是客户信息的唯一可靠来源。

按照这个原则，我们请求客户信息的结果只有客户信息，就会遇到信息的时效性问题，也就是说我们获取的结果和客户服务当前保存的不一致，所以我们要保存一个指向原始资源的引用。

当然如果一直从客户服务端获取资源，必然会使服务的负载过大，我们可以采用有效时限的方式，将信息缓存，来减小服务的负载。另外，对于不需要知道整个客户资源的服务，使用直接查询的方式会引入潜在的耦合。

## 13 版本管理

当接口发生改变时，我们应该如何管理这些改变呢？现在将这个问题划分成几个小问题，针对这些小问题进行处理。

### 13.1 尽可能推迟

对服务的修改，可能会导致服务消费者的破坏，减少破坏性修改影响的最好方法就是尽量不要修改。

另外，客户端要尽可能的灵活消费服务相应，来应对服务的修改。系统中的每一个模块都应该“宽进严出”，即对自己发送的东西要严格，对自己接受的东西要宽松。在请求/响应的场景下，可以帮助我们在服务做出修改的时候，减少消费方的修改。

### 13.2 尽早发现破坏性修改

使用**消费者驱动的契约**尽早定位可能会因为修改造成的破坏性。

消费者驱动的契约描述的是服务提供者向当前所有消费者承诺遵守的约束。一旦各消费者把自己的具体期望告知提供者，消费者驱动的契约就被创建了。在提供者方面创建的约束，确定了一个消费者驱动的契约。若提供者接受了一个消费者驱动的契约，那么它只需保证已有约束仍能得到满足，即可自行改进与修改其服务。

### 13.3 使用语义化的版本管理

语义化版本管理提出了一种预期，即查看服务的版本号就可以知道能否其进行集成。

语义化版本管理每一个版本都要遵循这样的格式：MAJOR.MINOR.PATCH。MAJOR的改变意味着其中包含不向后兼容的修改；MINOR的改变意味着增加了新功能，是向后兼容的；PATCH的改变意味着修复功能缺陷。

### 13.4 不同的接口共存

当修改无法边的情况下，我们考虑的就是限制修改带来的影响。我们不想强迫消费者跟随服务端一起升级，因为这样破坏了独立性。避免这个问题的一个方案是，在服务端新老接口同时并存。

我们在发布一个破坏性修改的时候，部署一个新老接口同时并存的版本。这样我们可以尽快的发布服务，同时不影响其他服务的，并且给消费者迁移的时间。当没有消费者使用老接口的时候，可以对其进行删除。这其实就是一个**扩张/收缩模式**的实例，它允许我们对破坏性修改进行平滑过度。

当使用这种方案，并且随着消费者的数量增加和破坏性修改次数的增加，就会出现混乱的局面。维护多个版本的接口将会带来更多的负担，尤其是在测试上。

如果我们采用多版本接口共存的方式，我们需要一种方式对不同的请求进行路由。可以在请求中添加版本信息。

### 13.5 同时使用多个版本的服务

另一个版本管理的方式是，同时运行不同版本的服务。老用户路由到老版本，新用户可以看到新的服务。这个方式不推荐使用，因为这样会引入更多的复杂性。短期内同时存在两个版本的服务是合理的，不用版本的服务可能同时存在几个小时，而且一般只有两个版本。

## 14 用户界面 

无论服务端提供的界面是生硬API还是用户界面，但是重要的是要考虑这个界面能否支持服务之间的集成。

在为用户界面提供服务的时候，我们可以采用网关对多个底层接口调用进行聚合。<font color="red">网关如何对接口进行聚合？</font>

## 15 与第三方软件集成

与第三方集没有特别重点关注的点，集成的时候可以选择将第三方软件包装成一个服务，对外开放接口，但是这种局限性依旧太大，像CMS之类的系统有可能做到。

在将地方替换为自己的系统时，我们可以采用**绞杀者模式**。绞杀者模式可以拦截对老系统的调用，并且将这些请求路由到新的系统上。采用这种方式让我们逐步替换老的系统。<font color="red">绞杀者模式如何实现？</font>

## 16 小结

1.怎样集成可以保证服务间的低耦合与高内聚？

