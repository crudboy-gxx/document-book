# 6 部署

部署单块系统的流程很简单，但是在相互依赖的微服务中，部署确实完全不同。如果部署的方式不合理，那么部署带来的复杂度会让人痛苦。

我们从持续集成和持续交付说起。

## 1 持续集成简介

持续集成（CI）已经出现了很久，但是我们有必要学习下基本用法。因为在微服务之间的映射、构建以及代码库版本方面，存在很多种选择。

CI能够保证新提交的代码和已有代码的集成，从而让所有人保持同步。CI服务器会检测到代码提交并检出，去验证构建和测试是否能够通过。在这个流程中，我们会产出构建物。理想情况下，我们应该将通过验证的构建物放到仓库中，以供重复使用。

CI的好处有很多，我们能够得到关于代码质量的某种程度的快速反馈，我们能够从已部署的构建物回溯到相应的代码，可以使在这些代码和构建物上运行过的测试可视化。

### 真的在做CI吗

持续集成允许我们更快速、更容易的修改代码。如果没有持续集成，向微服务架构转型将会很痛苦。

真正理解CI的三个问题。

+ 是否每天将代码合并入主线。

  如果我们的代码没有频繁的被放在一起，那么将来集成就非常困难。

+ 是否有一组测试来验证修改。

  如果没有测试，我们只知道代码继承后没有语法错误，但是无法知道系统的行为已经被破坏。

+ 当构建失败后，团队是否将修复CI来当作第一优先级事情来做。

  当构建失败后，团队应该停止提交修改，只允许提交修复构建的代码。

## 2 把持续集成映射到微服务

当在微服务中做持续集成的时候，我么需要考虑将CI的构建映射到每一个服务上。

在项目的初期，我们可以采用把所有代码放到一起的方式。我们有一个代码库，只构建一次，产生多个构建产物。这种方式是最简单的，第一，我们只需要关心一个代码库，对于开发开说只需要提交一次，并且也只构建一次。但是这种模式只在项目早期使用。他的弊端有三个，一个是因为代码都在一起，每次构建都全部构建，花费时间多。第二是部署的时候不能确定服务应该部署，哪个应该部署。第三，如果构建失败，在问题解决之前，所有人的代码都不能在提交。

上述方式还有一个变种，就是保留一个代码库，然后会有多个CI分别映射到代码库的不同部分。这种方式是把双刃剑，一方面简化了检入检出的流程，另一方面因为提交多个服务是一件很容易的事情，很容易造成服务耦合的修改。

最好的方式就是每一个服务都有自己的CI，可以单独构建，这样就可以尽量避免上面提到的问题。

## 3 构建流水线和持续交付

**构建流水线**就是将构建分为多个阶段，第一阶段运行快速测试，第二阶段运行耗时测试。这样做可以尽量避免构建过程中快速测试失败，耗时测试继续运行的浪费时间问题。并且可以很好的跟踪构建的进度，因为每一个构建阶段都会给出相应的结果。

持续交付（CD）是基于构建流水线的概念引出的，并在之上有所发展。CD会检查每次提交是否达到了部署正式环境的要求，并持续的将这些信息反馈给我们。

为了更好的理解这个概念，我们需要对从代码提交到部署生产环境这个过程中，所需要经历的流程进行建模，并知道哪些版本的软件是可以发布的。通过对整个软件上线过程进行建模， 软件质量的可视化得到了极大改善， 这可以大大减少发布之间的间隔， 因为可以在一个集中的地方看到构建和发布流程。

![1584924625170](D:\document\typora\1584924625170.png)

### 不可避免的例外

在一个团队刚开始的时候，我们会花很多时间来识别出服务边界，在识别出稳定的边界之后，会将代码放到相应的服务中。

在这个最开始的阶段，我们经常会出现跨服务边界的修改，会将代码移入移出某个服务。这个时候我们使用一个构建的方式，可以减少跨服务修改带来的代价。当然，这应该是一个过渡的时期，当我们的边界和API稳定的时候，我们需要将服务放到单独的构建中。

## 4 平台特定的构建物

大多数技术栈都有相应的构建物类型，自动化可以对不同构建物的底层机制进行屏蔽，会简化部署。

## 5 操作系统构建物

有一种方法可以避免多种技术栈下的构建物所带来的问题， 那就是使用操作系统支持的构建物。  

## 6 定制化镜像

将镜像作为构建物，可以减少环境搭建和部署的时间。

不可变服务器，禁止对任何运行的服务器修改，可以解决服务飘逸问题。

## 7 环境

环境之间的不同可能会引起一些问题，正式环境、测试环境、开发环境，不同环境中部署的服务是相同的， 但是每个环境的用途却不一样。  

## 8   服务配置

如果存在不同的环境之间的配置差异，我们应该如何在部署流程种处理呢？

我们应该只创建一个构建物，并将配置单独管理。

## 9 服务于主机之间的映射

每台机器应该有多少服务？

### 9.1 单主机多服务

说一下单主机多服务的弊端。

首先，这会让监控变得很困难，我们应该监控每个单独的服务还是整个机器呢？服务之间的相互影响也是不可避免的。其次，服务部署变得复杂，很难保证对一个服务的部署不会影响到其他的服务。

### 9.2 应用程序容器 

把不同的服务放在同一个容器中， 再把容器放置到单台主机上的模式。  

### 9.3 每个主机一个服务

这种模型避免了单主机多服务的问题， 并简化了监控和错误恢复。 这种方式也可以减少潜在的单点故障。  有更好的伸缩性，单独的安全策略。

### 9.4 平台即服务

PaaS平台还会帮你自动配置机器然后运行。 其中一些能够透明地对系统进行伸缩管理，这些平台还会帮你自动配置机器然后运行。 其中一些能够透明地对系统进行伸缩管理 。

## 10 自动化

使用支持自动化的技术非常重要。 让我们从管理主机的工具幵始考虑这个问题， 你能否通过写一行代码来启动或者关闭一个虚拟机？ 你能否自动化部署写好的软件？ 你能否不需要手工干预就完成数据库的变更？ 想要游刃有余地应对复杂的微服务架构， 自动化是必经之路。 

## 11 从物理机到虚拟机

 docker

## 12 一个部署接口

不管用干部署的底层平台和构建物是什么， 使用统一接口来部署给定的服务都是一个很关键的实践。

参数化的命令行调用是触发任何部署的最合理的方式。可以使用 CI 工具来触发脚本的调用，或者手动键入。

## 13 小节

首先，专注于保持服务能够独立于其他服务进行部署的能力。 我倾向于一个服务一个代码库， 并且每个微服务一个CI，因为只有这样才能实现独立部署。

接下来，尽可能的将每个服务放到单独的主机或容器中，并且坚持自动化部署。