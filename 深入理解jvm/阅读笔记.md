# 第1章 走进java

# 第2章 java内存区域与内存溢出异常
## 运行时数据区域
java虚机内存分为几个运行时数据区域：methodArea、heap；vmStack、nativeMethodStack、ProgramCounterRegister
+ 程序计数器
当前线程执行的字节码的行号指示器。字节码解释器工作时是通过改变程序计数器的值来选取下一条需要执行的字节码指令。
+ java虚拟机栈
java方法执行的线程内存模型。内个方法被执行时同步创建一个栈帧，用来存储局部变量表、操作数栈、动态链接等信息。
在Java虚机栈中，比较关注的是“局部变量表”。里面存放了编译期可知的基本数据类型、对象引用、returnAddress类型，这些数据类型在局部变量中是以变量槽slot来表示，局部变量表所需的内存空间在编译期间完成分配。
+ 本地方法栈
与java虚拟机栈非常相似，java虚拟机栈为虚拟机执行java方法服务，本地方法栈为虚拟机使用本地方法服务？
+ java堆
他是一块被所有线程共享的内存区域，在虚机启动时创建，用来存放对象实例。java堆是垃圾回收器管理的内存区域，为了更高效的垃圾回收和分配内存，垃圾回收期大部分都是基于分代收集理论设计，所以java堆中会被划分为新生代、老年代、永久代等空间。
+ 方法区
他是各个线程共享内存的区域，用来存储加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
jdk8之前，因为HotSpot团队为了方便管理方法区的内存，使用永生代来实现了方法区，但是这不受java虚拟机规范约束，jkd8已经取消了永生代的概念，改为在本地内存中实现的元空间代替。
+ 运行常量池
他是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。
+ 直接内存
直接内存不属于虚拟机的运行时数据区的部分。java的NIO类，可以使用native函数直接申请堆外内存使用。

## HotSpot虚拟机对象揭秘（堆）
+ 对象创建
java对象创建分配内存有两种策略，一个是“指针碰撞”，另一个是“空闲列表”。两种策略的选择方式由堆是否规整决定，而堆是否规整由垃圾回收器是否带有空间压缩能力决定。
并发下修改指针位置不安全问题有两个方案，一个是分配内存动作同步处理，另一个是使用本地线程缓冲。
+ 对象的内存布局
堆中内存分为三部分，对象头、实例数据、对其填充。对象头中存储了两类数据，第一类用于存储对象自身运行时数据，第二类是类型指针（对象指向它的类型元数据的指针）。
+ 对象访问定位
主流的对象访问定位主要使用句柄和直接指针两种。使用句柄访问，堆可能划分出一块句柄池，reference中存储的是对象句柄；句柄中包含对象实例数据与类型数据各自具体的地址。使用直接指针访问，内存布局就要考虑如何存放访问类型数据的信息，reference中存储的是对象地址。HotSpot主要使用第二种方式进行访问。

## 实战：OOM异常
+ java对内存溢出
堆内存溢出 java.lang.OutOfMemoryError: Java heap space。
解决这个内存区域异常的常规方式是通过内存映像分析工具对Dump出来的堆内存存储快照进行分析。第一步是确认内存中导致OOM的对象是否必要，如果非必要，按照内存泄漏排查；如果必要，按照内存溢出排查。内存泄漏的排查，找到泄漏对象是怎么样的引用路径、与哪些CGRoots相关联，才导致垃圾回收器无法回收它。内存溢出的排查，检查虚机Xmx和Xms的设置，在检查代码对生命周期过长、存储结构设计不合理等情况。